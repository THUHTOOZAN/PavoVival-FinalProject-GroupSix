import React, { useEffect, useMemo, useState } from "react";
import { useParams, useNavigate } from "react-router-dom";
import { db } from "../firebase";
import {
  onSnapshot,
  collection,
  doc,
  getDoc,
  orderBy,
  query,
  where,
} from "firebase/firestore";
import { useAuth } from "../context/AuthContext";
import FollowButton from "../components/FollowButton";
import { useUserCounters } from "../hooks/useUserCounters";
import PostModal from "../components/PostModal"; // ⬅️ NEW

export default function UserProfilePage() {
  const { uid } = useParams(); // profile owner
  const { user: me } = useAuth(); // signed-in user
  const nav = useNavigate();

  const [profile, setProfile] = useState(null);
  const [posts, setPosts] = useState([]);
  const [activePostId, setActivePostId] = useState(null); // ⬅️ modal control

  // realtime counters (your custom hook)
  const { followersCount, followingCount } = useUserCounters(uid);

  const viewingOwn = me?.uid === uid;
  const name = useMemo(() => profile?.displayName || "User", [profile]);

  // profile document (one-time fetch)
  useEffect(() => {
    if (!uid) return;
    (async () => {
      const p = await getDoc(doc(db, "users", uid));
      setProfile(p.exists() ? p.data() : { displayName: "User" });
    })();
  }, [uid]);

  // 🔴 realtime posts by this user (newest first)
  useEffect(() => {
    if (!uid) return;
    let unsub;

    try {
      const q = query(
        collection(db, "posts"),
        where("uid", "==", uid),
        orderBy("createdAt", "desc")
      );
      unsub = onSnapshot(q, (snap) => {
        setPosts(snap.docs.map((d) => ({ id: d.id, ...d.data() })));
      });
    } catch {
      // if composite index not built yet, fall back without orderBy
      const q = query(collection(db, "posts"), where("uid", "==", uid));
      unsub = onSnapshot(q, (snap) => {
        const rows = snap.docs.map((d) => ({ id: d.id, ...d.data() }));
        setPosts(rows);
      });
    }

    return () => unsub && unsub();
  }, [uid]);

  return (
    <div className="min-h-[calc(100vh-80px)] bg-[#FFE7CC]">
      <div className="max-w-5xl mx-auto px-4 py-6">
        <div className="bg-white/90 rounded-2xl shadow p-6 flex items-center gap-5">
          <img
            src={profile?.photoURL || "https://i.pravatar.cc/120?img=6"}
            className="w-20 h-20 rounded-full object-cover border"
            alt=""
          />

          <div className="flex-1">
            {/* HEADER ACTIONS */}
            <div className="flex items-center gap-3">
              <h1 className="text-2xl font-bold text-[#8B6F47]">{name}</h1>

              {viewingOwn ? (
                <>
                  <button
                    onClick={() => nav("/add-post")}
                    className="px-3 py-1.5 rounded-full bg-[#E2C299] text-white text-sm"
                  >
                    Create post
                  </button>
                  <button
                    onClick={() => nav("/settings")}
                    className="px-3 py-1.5 rounded-full bg-white border border-[#E2B887]/60 text-[#8B6F47] text-sm"
                  >
                    Edit profile
                  </button>
                </>
              ) : (
                <>
                  <FollowButton
                    me={{
                      uid: me?.uid,
                      displayName: me?.displayName,
                      photoURL: me?.photoURL,
                    }}
                    target={{
                      uid,
                      displayName: profile?.displayName,
                      photoURL: profile?.photoURL,
                    }}
                  />
                  <button
                    onClick={() => nav("/chat")}
                    className="px-3 py-1.5 rounded-full bg-[#FFE7CC] border border-[#E2B887]/60 text-[#8B6F47] text-sm"
                  >
                    Message
                  </button>
                </>
              )}
            </div>

            {/* COUNTS */}
            <div className="mt-1 flex gap-6 text-[#8B6F47]">
              <span>
                <b>{posts.length}</b> posts
              </span>
              <span>
                <b>{followersCount}</b> followers
              </span>
              <span>
                <b>{followingCount}</b> following
              </span>
            </div>

            {profile?.bio && (
              <p className="mt-2 text-[#8B6F47]/80">{profile.bio}</p>
            )}
          </div>
        </div>

        {/* POSTS GRID */}
        <div className="mt-6 grid grid-cols-2 md:grid-cols-3 gap-4">
          {posts.length === 0 ? (
            <div className="col-span-full text-center text-[#8B6F47]/70">
              No posts yet.
            </div>
          ) : (
            posts.map((p) => {
              const src =
                Array.isArray(p.images) && p.images[0] ? p.images[0] : "";
              return (
                <button
                  key={p.id}
                  onClick={() => setActivePostId(p.id)}
                  className="bg-white/90 rounded-xl shadow overflow-hidden text-left"
                >
                  {src ? (
                    <img
                      src={src}
                      alt=""
                      className="w-full aspect-square object-cover bg-[#F5F5F5]"
                      onError={(e) => {
                        // hide broken image tile gracefully
                        e.currentTarget.style.display = "none";
                      }}
                    />
                  ) : (
                    <div className="w-full aspect-square bg-[#F5F5F5]" />
                  )}
                  {p.text && (
                    <div className="px-3 py-2 text-sm text-[#8B6F47] line-clamp-2">
                      {p.text}
                    </div>
                  )}
                </button>
              );
            })
          )}
        </div>
      </div>

      {/* POST DETAIL MODAL */}
      {activePostId && (
        <PostModal postId={activePostId} onClose={() => setActivePostId(null)} />
      )}
    </div>
  );
}






import React, { useEffect, useMemo, useState } from "react";
import { useParams, useNavigate } from "react-router-dom";
import { db } from "../firebase";
import { onSnapshot, collection, doc, getDoc, getDocs, orderBy, query, where } from "firebase/firestore";
import { useAuth } from "../context/AuthContext";
import FollowButton from "../components/FollowButton";
import { useUserCounters } from "../hooks/useUserCounters";

export default function UserProfilePage() {
  const { uid } = useParams();                 // profile owner
  const { user: me } = useAuth();              // signed-in user
  const nav = useNavigate();

  const [profile, setProfile] = useState(null);
  const [posts, setPosts] = useState([]);

  // realtime counters maintained by Cloud Functions
  const { followersCount, followingCount } = useUserCounters(uid);

  const viewingOwn = me?.uid === uid;
  const name = useMemo(() => profile?.displayName || "User", [profile]);

  useEffect(() => {
    if (!uid) return;

    (async () => {
      // profile
      const p = await getDoc(doc(db, "users", uid));
      setProfile(p.exists() ? p.data() : { displayName: "User" });

      // posts by this user (newest first). If index missing, fallback without orderBy.
      try {
        const q1 = query(
          collection(db, "posts"),
          where("uid", "==", uid),
          orderBy("createdAt", "desc")
        );
        const ds = await getDocs(q1);
        setPosts(ds.docs.map((d) => ({ id: d.id, ...d.data() })));
      } catch {
        const q2 = query(collection(db, "posts"), where("uid", "==", uid));
        const ds = await getDocs(q2);
        setPosts(ds.docs.map((d) => ({ id: d.id, ...d.data() })));
      }
    })();
  }, [uid]);

  return (
    <div className="min-h-[calc(100vh-80px)] bg-[#FFE7CC]">
      <div className="max-w-5xl mx-auto px-4 py-6">
        <div className="bg-white/90 rounded-2xl shadow p-6 flex items-center gap-5">
          <img
            src={profile?.photoURL || "https://i.pravatar.cc/120?img=6"}
            className="w-20 h-20 rounded-full object-cover border"
            alt=""
          />

          <div className="flex-1">
            {/* HEADER ACTIONS */}
            <div className="flex items-center gap-3">
              <h1 className="text-2xl font-bold text-[#8B6F47]">{name}</h1>

              {viewingOwn ? (
                <>
                  <button
                    onClick={() => nav("/add-post")}
                    className="px-3 py-1.5 rounded-full bg-[#E2C299] text-white text-sm"
                  >
                    Create post
                  </button>
                  <button
                    onClick={() => nav("/settings")}
                    className="px-3 py-1.5 rounded-full bg-white border border-[#E2B887]/60 text-[#8B6F47] text-sm"
                  >
                    Edit profile
                  </button>
                </>
              ) : (
                <>
                  <FollowButton
                    me={{ uid: me?.uid, displayName: me?.displayName, photoURL: me?.photoURL }}
                    target={{ uid, displayName: profile?.displayName, photoURL: profile?.photoURL }}
                  />
                  <button
                    onClick={() => nav("/chat")}
                    className="px-3 py-1.5 rounded-full bg-[#FFE7CC] border border-[#E2B887]/60 text-[#8B6F47] text-sm"
                  >
                    Message
                  </button>
                </>
              )}
            </div>

            {/* COUNTS */}
            <div className="mt-1 flex gap-6 text-[#8B6F47]">
              <span><b>{posts.length}</b> posts</span>
              <span><b>{followersCount}</b> followers</span>
              <span><b>{followingCount}</b> following</span>
            </div>

            {profile?.bio && <p className="mt-2 text-[#8B6F47]/80">{profile.bio}</p>}
          </div>
        </div>

        {/* POSTS GRID */}
        <div className="mt-6 grid grid-cols-2 md:grid-cols-3 gap-4">
          {posts.length === 0 ? (
            <div className="col-span-full text-center text-[#8B6F47]/70">No posts yet.</div>
          ) : (
            posts.map((p) => (
              <div key={p.id} className="bg-white/90 rounded-xl shadow overflow-hidden">
                {Array.isArray(p.images) && p.images[0] ? (
                  <img src={p.images[0]} alt="" className="w-full aspect-square object-cover" />
                ) : (
                  <div className="w-full aspect-square bg-[#F5F5F5]" />
                )}
                {p.text && <div className="px-3 py-2 text-sm text-[#8B6F47] line-clamp-2">{p.text}</div>}
              </div>
            ))
          )}
        </div>
      </div>
    </div>
  );
}













// src/services/postApi.js
import { db, storage } from "../firebase";
import { addDoc, collection, serverTimestamp } from "firebase/firestore";
import { getDownloadURL, ref, uploadBytes } from "firebase/storage";

/**
 * createPost({ uid, text, files, author })
 * - Uploads up to 10 images to Storage
 * - Writes a post document to Firestore
 */
export async function createPost({ uid, text = "", files = [], author = {} }) {
  if (!uid) throw new Error("Missing uid");
  if (!Array.isArray(files)) throw new Error("Files must be an array");

  // Limit to 10 images
  const limitedFiles = files.slice(0, 10);
  const urls = [];

  for (const f of limitedFiles) {
    const path = `posts/${uid}/${Date.now()}_${f.name}`;
    const r = ref(storage, path);
    await uploadBytes(r, f);
    const url = await getDownloadURL(r);
    urls.push(url);
  }

  const payload = {
    uid, // must equal request.auth.uid
    text: text.trim(),
    images: urls, // up to 10 URLs
    createdAt: serverTimestamp(),
    commentCount: 0,
    author: {
      uid,
      displayName: author.displayName || "",
      photoURL: author.photoURL || "",
    },
  };

  await addDoc(collection(db, "posts"), payload);
}















import React, { useEffect, useState } from "react";
import { useAuth } from "../context/AuthContext";
import { db } from "../firebase";
import { doc, getDoc } from "firebase/firestore";
import { createPost } from "../services/postApi";
import { useNavigate } from "react-router-dom";

export default function AddPostPage() {
  const { user } = useAuth();
  const nav = useNavigate();

  const [profile, setProfile] = useState(null);
  const [text, setText] = useState("");
  const [files, setFiles] = useState([]);
  const [previews, setPreviews] = useState([]);
  const [posting, setPosting] = useState(false);
  const [err, setErr] = useState("");

  useEffect(() => {
    if (!user) return;
    (async () => {
      const snap = await getDoc(doc(db, "users", user.uid));
      setProfile(
        snap.exists()
          ? snap.data()
          : { displayName: user.displayName || "", photoURL: user.photoURL || "" }
      );
    })();
  }, [user]);

  function onPick(e) {
    const selected = Array.from(e.target.files || []);
    if (selected.length > 10) {
      alert("You can upload up to 10 images only.");
      e.target.value = ""; // reset input
      return;
    }
    setFiles(selected);
    setPreviews(selected.map((f) => URL.createObjectURL(f)));
  }

  async function onSubmit(e) {
    e.preventDefault();
    if (!user) return setErr("Please sign in first.");
    if (!text.trim() && files.length === 0)
      return setErr("Please add some text or images.");
    setPosting(true);
    setErr("");

    try {
      await createPost({
        uid: user.uid,
        text,
        files,
        author: {
          uid: user.uid,
          displayName: profile?.displayName || "",
          photoURL: profile?.photoURL || "",
        },
      });
      nav(`/u/${user.uid}`);
    } catch (e2) {
      console.error(e2);
      setErr(e2.message || "Post failed");
    } finally {
      setPosting(false);
    }
  }

  return (
    <div className="min-h-[calc(100vh-80px)] bg-[#FFE7CC] flex justify-center px-4 py-6">
      <form onSubmit={onSubmit} className="w-full max-w-xl bg-white/90 rounded-2xl shadow p-6">
        <h2 className="text-xl font-bold text-[#8B6F47] mb-4">Create Post</h2>

        <textarea
          value={text}
          onChange={(e) => setText(e.target.value)}
          placeholder="Say something about your pet…"
          className="w-full min-h-[120px] p-3 rounded-xl border-2 border-[#E2B887]/40 focus:border-[#E2B887] outline-none mb-3"
        />

        <label
          htmlFor="pick-post-images"
          className="inline-block mb-3 px-3 py-1 rounded-full bg-[#FFE7CC] text-[#8B6F47] border border-[#E2B887]/60 cursor-pointer"
        >
          Add images (max 10)
        </label>
        <input
          id="pick-post-images"
          type="file"
          accept="image/*"
          multiple
          className="hidden"
          onChange={onPick}
        />

        {previews.length > 0 && (
          <div className="grid grid-cols-2 sm:grid-cols-3 gap-3 mb-4">
            {previews.map((src, i) => (
              <img
                key={i}
                src={src}
                alt={`preview-${i}`}
                className="aspect-square object-cover rounded-xl border"
              />
            ))}
          </div>
        )}

        {err && (
          <div className="mb-3 text-sm text-red-700 bg-red-50 border border-red-200 rounded-2xl px-3 py-2">
            {err}
          </div>
        )}

        <button
          type="submit"
          disabled={posting}
          className="w-full py-3 rounded-2xl bg-[#E2B887] text-white font-semibold disabled:opacity-50"
        >
          {posting ? "Posting…" : "Post"}
        </button>
      </form>
    </div>
  );
}








import React, { useEffect, useState } from "react";
import { useAuth } from "../context/AuthContext";
import { db } from "../firebase";
import { doc, getDoc } from "firebase/firestore";
import { createPost } from "../services/postApi";
import { useNavigate } from "react-router-dom";

export default function AddPostPage() {
  const { user } = useAuth();
  const nav = useNavigate();

  const [profile, setProfile] = useState(null);
  const [text, setText] = useState("");
  const [files, setFiles] = useState([]);
  const [previews, setPreviews] = useState([]);
  const [posting, setPosting] = useState(false);
  const [err, setErr] = useState("");

  useEffect(() => {
    if (!user) return;
    (async () => {
      const snap = await getDoc(doc(db, "users", user.uid));
      setProfile(
        snap.exists()
          ? snap.data()
          : { displayName: user.displayName || "", photoURL: user.photoURL || "" }
      );
    })();
  }, [user]);

  function onPick(e) {
    const list = Array.from(e.target.files || []).slice(0, 10);
    setFiles(list);
    setPreviews(list.map((f) => URL.createObjectURL(f)));
  }

  async function onSubmit(e) {
    e.preventDefault();
    if (!user) return setErr("Please sign in first.");
    setPosting(true);
    setErr("");

    try {
      await createPost({
        uid: user.uid, // MUST equal request.auth.uid (rules)
        text,
        files,         // raw File[]; service uploads & writes image URLs
        author: {
          uid: user.uid,
          displayName: profile?.displayName || "",
          photoURL: profile?.photoURL || "",
        },
      });
      nav(`/u/${user.uid}`); // go to my profile (adjust if your route differs)
    } catch (e2) {
      console.error(e2);
      setErr(e2.message || "Post failed");
    } finally {
      setPosting(false);
    }
  }

  return (
    <div className="min-h-[calc(100vh-80px)] bg-[#FFE7CC] flex justify-center px-4 py-6">
      <form onSubmit={onSubmit} className="w-full max-w-xl bg-white/90 rounded-2xl shadow p-6">
        <h2 className="text-xl font-bold text-[#8B6F47] mb-4">Create Post</h2>

        <textarea
          value={text}
          onChange={(e) => setText(e.target.value)}
          placeholder="Say something about your pet…"
          className="w-full min-h-[120px] p-3 rounded-xl border-2 border-[#E2B887]/40 focus:border-[#E2B887] outline-none mb-3"
        />

        <label
          htmlFor="pick-post-images"
          className="inline-block mb-3 px-3 py-1 rounded-full bg-[#FFE7CC] text-[#8B6F47] border border-[#E2B887]/60 cursor-pointer"
        >
          Add images
        </label>
        <input
          id="pick-post-images"
          type="file"
          accept="image/*"
          multiple
          className="hidden"
          onChange={onPick}
        />

        {previews.length > 0 && (
          <div className="grid grid-cols-2 sm:grid-cols-3 gap-3 mb-4">
            {previews.map((src, i) => (
              <img key={i} src={src} alt="" className="aspect-square object-cover rounded-xl border" />
            ))}
          </div>
        )}

        {err && (
          <div className="mb-3 text-sm text-red-700 bg-red-50 border border-red-200 rounded-2xl px-3 py-2">
            {err}
          </div>
        )}

        <button
          type="submit"
          disabled={posting}
          className="w-full py-3 rounded-2xl bg-[#E2B887] text-white font-semibold disabled:opacity-50"
        >
          {posting ? "Posting…" : "Post"}
        </button>
      </form>
    </div>
  );
}








// src/services/postApi.js
import { db, storage } from "../firebase";
import { addDoc, collection, serverTimestamp } from "firebase/firestore";
import { getDownloadURL, ref, uploadBytes } from "firebase/storage";

/**
 * createPost({ uid, text, files, author })
 * - uploads images -> returns URLs
 * - writes /posts doc with required fields for security rules
 */
export async function createPost({ uid, text = "", files = [], author = {} }) {
  if (!uid) throw new Error("Missing uid");
  // 1) Upload images (if any)
  const urls = [];
  for (const f of files) {
    const path = `posts/${uid}/${Date.now()}_${f.name}`;
    const r = ref(storage, path);
    await uploadBytes(r, f);
    const url = await getDownloadURL(r);
    urls.push(url);
  }

  // 2) Firestore payload must match rules
  const payload = {
    uid,                            // MUST equal request.auth.uid
    text: text.trim(),
    images: urls,                   // array of strings
    createdAt: serverTimestamp(),
    commentCount: 0,
    author: {
      uid,
      displayName: author.displayName || "",
      photoURL: author.photoURL || "",
    },
  };

  // 3) Write to /posts (public read; author-only write)
  await addDoc(collection(db, "posts"), payload);
}









import React, { useEffect, useState } from "react";
import { useAuth } from "../context/AuthContext";
import { db } from "../firebase";
import { doc, getDoc } from "firebase/firestore";
import { createPost } from "../services/postApi";
import { useNavigate } from "react-router-dom";
import { getAuth } from "firebase/auth";

export default function AddPostPage() {
  const { user } = useAuth();
  const navigate = useNavigate();

  const [profile, setProfile] = useState(null);
  const [text, setText] = useState("");
  const [files, setFiles] = useState([]);
  const [previews, setPreviews] = useState([]);
  const [posting, setPosting] = useState(false);
  const [err, setErr] = useState("");

  const auth = getAuth();
  console.log("Current user: ", auth.currentUser?.uid);
  
  // Load profile to show author name/photo in post
  useEffect(() => {
    if (!user) return;
    (async () => {
      const snap = await getDoc(doc(db, "users", user.uid));
      setProfile(snap.exists() ? snap.data() : { displayName: user.displayName, photoURL: user.photoURL });
    })();
  }, [user]);

  function onPick(e) {
    const list = Array.from(e.target.files || []).slice(0, 10);
    setFiles(list);
    setPreviews(list.map((f) => URL.createObjectURL(f)));
  }

  async function onSubmit(e) {
    e.preventDefault();
    if (!user) return setErr("Please sign in");
    setPosting(true);
    setErr("");

    try {
      await createPost({
        uid: user.uid,                                 // <<<<< ensures NOT "undefined"
        author: { displayName: profile?.displayName, photoURL: profile?.photoURL },
        text,
        files,
      });
      // go to profile after posting
      navigate("/profile");
    } catch (e2) {
      console.error(e2);
      setErr(e2.message || "Post failed");
    } finally {
      setPosting(false);
    }
  }

  return (
    <div className="min-h-[calc(100vh-80px)] bg-[#FFE7CC] flex justify-center px-4 py-6">
      <form
        onSubmit={onSubmit}
        className="w-full max-w-xl bg-white/90 rounded-2xl shadow p-6"
      >
        <h2 className="text-xl font-bold text-[#8B6F47] mb-4">Create Post</h2>

        <textarea
          value={text}
          onChange={(e) => setText(e.target.value)}
          placeholder="Say something about your pet…"
          className="w-full min-h-[120px] p-3 rounded-xl border-2 border-[#E2B887]/40 focus:border-[#E2B887] outline-none mb-3"
        />

        <label
          htmlFor="pick-post-images"
          className="inline-block mb-3 px-3 py-1 rounded-full bg-[#FFE7CC] text-[#8B6F47] border border-[#E2B887]/60 cursor-pointer"
        >
          Add images
        </label>
        <input
          id="pick-post-images"
          type="file"
          accept="image/*"
          multiple
          className="hidden"
          onChange={onPick}
        />

        {previews.length > 0 && (
          <div className="grid grid-cols-2 sm:grid-cols-3 gap-3 mb-4">
            {previews.map((src, i) => (
              <img key={i} src={src} alt="" className="aspect-square object-cover rounded-xl border" />
            ))}
          </div>
        )}

        {err && (
          <div className="mb-3 text-sm text-red-700 bg-red-50 border border-red-200 rounded-2xl px-3 py-2">
            {err}
          </div>
        )}

        <button
          type="submit"
          disabled={posting}
          className="w-full py-3 rounded-2xl bg-[#E2B887] text-white font-semibold disabled:opacity-50"
        >
          {posting ? "Posting…" : "Post"}
        </button>
      </form>
    </div>
  );
}












rules_version = '2';
service cloud.firestore {
  match /databases/{db}/documents {

    /* ---------- helpers ---------- */
    function signedIn() {
      return request.auth != null;
    }
    function isUser(uid) {
      return signedIn() && request.auth.uid == uid;
    }
    function inArray(arr, v) {
      return arr != null && (v in arr);
    }

    /* ---------- USERS (public read; owner write) ---------- */
    match /users/{uid} {
      allow read: if true;
      allow create, update, delete: if isUser(uid);
    }

    /* ---------- POSTS (public feed) ---------- */
    match /posts/{postId} {
      allow read: if true;

      // author uid must match the authenticated user
      allow create: if signedIn() &&
        request.resource.data.uid == request.auth.uid;

      allow update, delete: if signedIn() &&
        resource.data.uid == request.auth.uid;

      // COMMENTS: anyone signed-in may add; only author can delete
      match /comments/{commentId} {
        allow read: if true;
        allow create: if signedIn();  // author stored in doc
        allow update, delete: if signedIn() &&
          resource.data.author.uid == request.auth.uid;
      }

      // LIKES: document id (or field) should be liker uid
      // allows toggle like/unlike by the same user only
      match /likes/{likeUid} {
        allow read: if true;
        allow create, update, delete: if isUser(likeUid);
      }
    }

    /* ---------- FOLLOWS (fan-out: following & followers) ---------- */
    match /follows/{uid} {

      allow read: if true;

      // I can edit my "following" subcollection
      match /following/{targetUid} {
        allow read: if true;
        allow write: if isUser(uid);
      }

      // Anyone can write a doc under *their own* uid in someone else’s "followers"
      // (this is what your follow/unfollow code does)
      match /followers/{sourceUid} {
        allow read: if true;
        allow write: if isUser(sourceUid);
      }
    }

    /* ---------- NOTIFICATIONS (private per user) ---------- */
    // Structure: notifications/{uid}/items/{notifId}
    // Client creates when performing an action (follow/like/comment).
    match /notifications/{uid} {
      // Only the owner can read their notifications list
      allow read: if isUser(uid);

      match /items/{notifId} {
        // Owner can read & mark read/delete
        allow read, update, delete: if isUser(uid);

        // Anyone signed-in can create a notification addressed to {uid},
        // but the 'fromUid' must be the caller.
        allow create: if signedIn() &&
          request.resource.data.fromUid == request.auth.uid &&
          request.resource.data.type in ['follow','like','comment'] &&
          // basic shape hardening
          request.resource.data.createdAt is timestamp &&
          request.resource.data.read is bool;
      }
    }

    /* ---------- CHATS (1:1) ---------- */
    // chats/{chatId} has: members: [uidA, uidB], typing: {uid: bool}, lastMessage, lastMessageAt
    match /chats/{chatId} {
      // Only members can read the chat document
      allow read: if signedIn() && inArray(resource.data.members, request.auth.uid);

      // Create a chat if the caller is one of the members they are writing
      allow create: if signedIn() &&
        inArray(request.resource.data.members, request.auth.uid);

      // Members can update limited fields of the chat doc
      allow update: if signedIn() &&
        inArray(resource.data.members, request.auth.uid) &&
        // Only allow these fields to change:
        request.resource.data.diff(resource.data).changedKeys()
          .hasOnly(['lastMessage', 'lastMessageAt', 'typing', 'members']);

      // Delete forbidden from clients
      allow delete: if false;

      // Subcollection: messages
      match /messages/{messageId} {
        // Only chat members can read
        allow read: if signedIn() &&
          inArray(get(/databases/$(db)/documents/chats/$(chatId)).data.members, request.auth.uid);

        // Create: sender must be the caller and a member of the chat
        allow create: if signedIn() &&
          request.resource.data.senderId == request.auth.uid &&
          inArray(get(/databases/$(db)/documents/chats/$(chatId)).data.members, request.auth.uid);

        // Update (e.g., append to seenBy): only members
        allow update: if signedIn() &&
          inArray(get(/databases/$(db)/documents/chats/$(chatId)).data.members, request.auth.uid);

        // No deletes from clients
        allow delete: if false;
      }
    }

    /* ---------- OPTIONAL: REPORTS (if you use them) ---------- */
    match /reports/{reportId} {
      allow read: if signedIn();
      allow create: if signedIn() &&
        request.resource.data.reporterId == request.auth.uid;
      allow update, delete: if isUser(resource.data.reporterId);
    }
  }
}







import React, { useEffect, useMemo, useRef, useState } from "react";
import { useAuth } from "../context/AuthContext";
import { db, storage } from "../firebase";
import {
  collection,
  doc,
  getDocs,
  onSnapshot,
  orderBy,
  query,
  serverTimestamp,
  setDoc,
  addDoc,
  updateDoc,
  where,
  writeBatch,
} from "firebase/firestore";
import { getDownloadURL, ref as sref, uploadBytes } from "firebase/storage";
import { Send } from "lucide-react";

const chatIdFor = (a, b) => [a, b].sort().join("_");
const debounce = (fn, ms = 600) => {
  let t;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...args), ms);
  };
};
const formatTime = (d) =>
  d ? new Date(d).toLocaleTimeString([], { hour: "numeric", minute: "2-digit" }) : "";

export default function ChatPage() {
  const { user } = useAuth();
  const [allUsers, setAllUsers] = useState([]);
  const [selectedChatUser, setSelectedChatUser] = useState(null);
  const [activeChatId, setActiveChatId] = useState(null);
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState("");
  const [isOtherTyping, setIsOtherTyping] = useState(false);
  const [pendingImage, setPendingImage] = useState(null);
  const [pendingURL, setPendingURL] = useState("");

  const messagesEndRef = useRef(null);

  // Load users (excluding self)
  useEffect(() => {
    if (!user) return;
    (async () => {
      const snap = await getDocs(collection(db, "users"));
      const list = snap.docs
        .map((d) => ({ id: d.id, ...d.data() }))
        .filter((u) => u.uid !== user.uid);
      setAllUsers(list);
    })();
  }, [user]);

  // Open chat with another user
  async function openChatWith(other) {
    if (!user || !other?.uid) return;
    const id = chatIdFor(user.uid, other.uid);
    setSelectedChatUser(other);
    setActiveChatId(id);

    await setDoc(
      doc(db, "chats", id),
      {
        members: [user.uid, other.uid],
        createdAt: serverTimestamp(),
        lastMessage: "",
        lastMessageAt: serverTimestamp(),
      },
      { merge: true }
    );
    markSeen(id, user.uid).catch(() => {});
  }

  // Listen for messages
  useEffect(() => {
    if (!activeChatId) return;
    const q = query(
      collection(db, "chats", activeChatId, "messages"),
      orderBy("createdAt", "asc")
    );

    const unsub = onSnapshot(q, (snap) => {
      const rows = snap.docs.map((d) => ({
        id: d.id,
        ...d.data(),
        _ts: d.data().createdAt?.toDate ? d.data().createdAt.toDate() : new Date(),
        seenBy: Array.isArray(d.data().seenBy) ? d.data().seenBy : [],
      }));
      setMessages(rows);
      setTimeout(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
      }, 0);
      if (activeChatId && user) markSeen(activeChatId, user.uid).catch(() => {});
    });
    return unsub;
  }, [activeChatId, user]);

  // Listen for typing
  useEffect(() => {
    if (!activeChatId || !user) return;
    const chatRef = doc(db, "chats", activeChatId);
    const unsub = onSnapshot(chatRef, (snap) => {
      const typing = snap.data()?.typing || {};
      const otherTyping = Object.keys(typing).some(
        (uid) => uid !== user.uid && typing[uid] === true
      );
      setIsOtherTyping(otherTyping);
    });
    return unsub;
  }, [activeChatId, user]);

  // Mark messages as seen
  async function markSeen(chatId, myUid) {
    const msgsQ = query(
      collection(db, "chats", chatId, "messages"),
      where("senderId", "!=", myUid)
    );
    const snap = await getDocs(msgsQ);
    if (snap.empty) return;
    const batch = writeBatch(db);
    snap.forEach((d) => {
      const seenBy = Array.isArray(d.data().seenBy) ? d.data().seenBy : [];
      if (!seenBy.includes(myUid)) {
        batch.update(d.ref, { seenBy: [...seenBy, myUid] });
      }
    });
    await batch.commit();
  }

  // Send text message
  async function handleSendMessage(e) {
    e?.preventDefault?.();
    if (!newMessage.trim() || !activeChatId || !user) return;
    const text = newMessage.trim();
    setNewMessage("");

    updateDoc(doc(db, "chats", activeChatId), {
      [`typing.${user.uid}`]: false,
    }).catch(() => {});

    await addDoc(collection(db, "chats", activeChatId, "messages"), {
      senderId: user.uid,
      text,
      createdAt: serverTimestamp(),
      seenBy: [user.uid],
    });

    await updateDoc(doc(db, "chats", activeChatId), {
      lastMessage: text,
      lastMessageAt: serverTimestamp(),
    });
  }

  // Send image
  async function handleSendImage(file) {
    if (!file || !activeChatId || !user) return;
    const path = `chats/${activeChatId}/${user.uid}/${Date.now()}_${file.name}`;
    const r = sref(storage, path);
    await uploadBytes(r, file);
    const url = await getDownloadURL(r);

    await addDoc(collection(db, "chats", activeChatId, "messages"), {
      senderId: user.uid,
      imageUrl: url,
      createdAt: serverTimestamp(),
      seenBy: [user.uid],
    });

    await updateDoc(doc(db, "chats", activeChatId), {
      lastMessage: "📷 Photo",
      lastMessageAt: serverTimestamp(),
    });
  }

  const debouncedStopTyping = useMemo(
    () =>
      debounce(() => {
        if (activeChatId && user) {
          updateDoc(doc(db, "chats", activeChatId), {
            [`typing.${user.uid}`]: false,
          }).catch(() => {});
        }
      }, 1000),
    [activeChatId, user]
  );

  return (
    <div className="flex h-[calc(100vh-80px)] bg-white rounded-2xl shadow overflow-hidden">
      {/* LEFT: Users List */}
      <div className="w-1/3 border-r border-[#E2B887]/30 p-4 overflow-y-auto">
        <h2 className="text-lg font-bold text-[#8B6F47] mb-3">Messages</h2>
        {allUsers.length === 0 ? (
          <p className="text-[#8B6F47]/60">No other users yet.</p>
        ) : (
          <ul className="space-y-2">
            {allUsers.map((u) => (
              <li key={u.uid}>
                <button
                  onClick={() => openChatWith(u)}
                  className={`w-full flex items-center gap-3 p-2 rounded-lg hover:bg-[#FFF4E6] transition ${
                    selectedChatUser?.uid === u.uid ? "bg-[#FFF4E6]" : ""
                  }`}
                >
                  <img
                    src={u.photoURL || "https://i.pravatar.cc/48?img=1"}
                    alt={u.displayName || u.email || "user"}
                    className="w-10 h-10 rounded-full object-cover"
                  />
                  <div className="text-left">
                    <div className="text-[#8B6F47] font-semibold">
                      {u.displayName || u.email}
                    </div>
                    <div className="text-xs text-[#8B6F47]/60">{u.email}</div>
                  </div>
                </button>
              </li>
            ))}
          </ul>
        )}
      </div>

      {/* RIGHT: Chat Area */}
      <div className="w-2/3 flex flex-col">
        {selectedChatUser ? (
          <>
            <div className="bg-[#F5F5F5] p-4 border-b border-[#E2B887]/30 flex items-center space-x-3">
              <img
                src={selectedChatUser.photoURL || "https://i.pravatar.cc/40?img=2"}
                alt={selectedChatUser.displayName || "user"}
                className="w-10 h-10 rounded-full object-cover"
              />
              <h3 className="text-xl font-bold text-[#8B6F47]">
                {selectedChatUser.displayName || selectedChatUser.email}
              </h3>
              {isOtherTyping && (
                <span className="text-xs text-[#8B6F47]/70 ml-2">typing…</span>
              )}
            </div>

            <div className="flex-1 p-4 overflow-y-auto space-y-4">
              {messages.length === 0 ? (
                <p className="text-center text-[#8B6F47]/60">
                  Start a conversation!
                </p>
              ) : (
                messages.map((msg) => (
                  <div
                    key={msg.id}
                    className={`flex ${
                      msg.senderId === user.uid ? "justify-end" : "justify-start"
                    }`}
                  >
                    <div
                      className={`max-w-[70%] p-3 rounded-xl ${
                        msg.senderId === user.uid
                          ? "bg-[#E2B887] text-white"
                          : "bg-[#F5F5F5] text-[#8B6F47]"
                      }`}
                    >
                      {msg.imageUrl ? (
                        <img
                          src={msg.imageUrl}
                          alt="sent"
                          className="rounded-lg w-full max-w-[200px] object-cover"
                        />
                      ) : (
                        <p>{msg.text}</p>
                      )}
                      <span className="text-xs opacity-70 mt-1 block">
                        {formatTime(msg._ts)}
                      </span>
                      {msg.senderId === user.uid &&
                        Array.isArray(msg.seenBy) &&
                        msg.seenBy.length > 1 && (
                          <span className="text-[10px] opacity-70 mt-1 block text-right">
                            Seen
                          </span>
                        )}
                    </div>
                  </div>
                ))
              )}
              <div ref={messagesEndRef} />
            </div>

            {/* IMAGE PREVIEW */}
            {pendingImage && (
              <div className="px-4 pt-3 pb-2 border-t border-[#E2B887]/30 bg-[#FFF8EF] flex items-center gap-3 justify-between">
                <img
                  src={pendingURL}
                  alt="preview"
                  className="w-20 h-20 rounded-lg object-cover border shadow-sm"
                />
                <div className="flex gap-2">
                  <button
                    onClick={async () => {
                      const f = pendingImage;
                      setPendingImage(null);
                      setPendingURL("");
                      await handleSendImage(f);
                    }}
                    className="px-4 py-2 bg-[#E2B887] text-white rounded-lg hover:bg-[#D4A77C]"
                  >
                    Send
                  </button>
                  <button
                    onClick={() => {
                      if (pendingURL) URL.revokeObjectURL(pendingURL);
                      setPendingImage(null);
                      setPendingURL("");
                    }}
                    className="px-4 py-2 border border-[#E2B887]/60 rounded-lg text-[#8B6F47] hover:bg-[#FFF1DF]"
                  >
                    Cancel
                  </button>
                </div>
              </div>
            )}

            {/* INPUT BAR */}
            <form
              onSubmit={handleSendMessage}
              className="p-4 border-t border-[#E2B887]/30 flex items-center space-x-3"
            >
              <input
                type="text"
                value={newMessage}
                onChange={(e) => {
                  setNewMessage(e.target.value);
                  if (activeChatId && user) {
                    updateDoc(doc(db, "chats", activeChatId), {
                      [`typing.${user.uid}`]: true,
                    }).catch(() => {});
                    debouncedStopTyping();
                  }
                }}
                placeholder="Type a message..."
                className="flex-1 p-3 border border-[#E2B887]/50 rounded-lg focus:outline-none focus:ring-2 focus:ring-[#E2B887] text-[#8B6F47] placeholder-[#8B6F47]/50"
              />
              <input
                type="file"
                accept="image/*"
                onChange={(e) => {
                  const f = e.target.files?.[0];
                  if (!f) return;
                  setPendingImage(f);
                  const url = URL.createObjectURL(f);
                  setPendingURL(url);
                }}
                className="hidden"
                id="chat-upload"
              />
              <label
                htmlFor="chat-upload"
                className="cursor-pointer bg-[#FFE7CC] text-[#8B6F47] px-3 py-3 rounded-full border border-[#E2B887]/60"
                title="Send photo"
              >
                📷
              </label>
              <button
                type="submit"
                className="bg-[#E2B887] text-white p-3 rounded-full hover:bg-[#D4A77C] transition-colors"
                title="Send"
              >
                <Send className="w-6 h-6" />
              </button>
            </form>
          </>
        ) : (
          <div className="flex-1 flex items-center justify-center text-center text-[#8B6F47]/60">
            <p className="text-xl">Select a chat to start messaging</p>
          </div>
        )}
      </div>
    </div>
  );
}








// src/pages/ProfilePage.js  (MY profile)
import React, { useEffect, useMemo, useState } from "react";
import { useNavigate } from "react-router-dom";
import { db } from "../firebase";
import { collection, doc, getDoc, getDocs, orderBy, query, where } from "firebase/firestore";
import { useAuth } from "../context/AuthContext";
import { useUserCounters } from "../hooks/useUserCounters";

export default function ProfilePage() {
  const { user: me } = useAuth();
  const nav = useNavigate();

  const uid = me?.uid;                 // <-- my own uid
  const [profile, setProfile] = useState(null);
  const [posts, setPosts] = useState([]);

  // live counts from users/{uid}
  const { followersCount, followingCount } = useUserCounters(uid);

  const name = useMemo(() => profile?.displayName || "User", [profile]);

  useEffect(() => {
    if (!uid) return;

    (async () => {
      // my profile
      const p = await getDoc(doc(db, "users", uid));
      setProfile(p.exists() ? p.data() : { displayName: "User" });

      // my posts (newest first; fallback if no index)
      try {
        const q1 = query(
          collection(db, "posts"),
          where("uid", "==", uid),
          orderBy("createdAt", "desc")
        );
        const ds = await getDocs(q1);
        setPosts(ds.docs.map((d) => ({ id: d.id, ...d.data() })));
      } catch {
        const q2 = query(collection(db, "posts"), where("uid", "==", uid));
        const ds = await getDocs(q2);
        setPosts(ds.docs.map((d) => ({ id: d.id, ...d.data() })));
      }
    })();
  }, [uid]);

  return (
    <div className="min-h-[calc(100vh-80px)] bg-[#FFE7CC]">
      <div className="max-w-5xl mx-auto px-4 py-6">
        <div className="bg-white/90 rounded-2xl shadow p-6 flex items-center gap-5">
          <img
            src={profile?.photoURL || "https://i.pravatar.cc/120?img=6"}
            className="w-20 h-20 rounded-full object-cover border"
            alt=""
          />

          <div className="flex-1">
            {/* HEADER ACTIONS — NO FOLLOW ON MY OWN PROFILE */}
            <div className="flex items-center gap-3">
              <h1 className="text-2xl font-bold text-[#8B6F47]">{name}</h1>

              <button
                onClick={() => nav("/add-post")}
                className="px-3 py-1.5 rounded-full bg-[#E2C299] text-white text-sm"
              >
                Create post
              </button>
              <button
                onClick={() => nav("/settings")}
                className="px-3 py-1.5 rounded-full bg-white border border-[#E2B887]/60 text-[#8B6F47] text-sm"
              >
                Edit profile
              </button>
            </div>

            {/* COUNTS */}
            <div className="mt-1 flex gap-6 text-[#8B6F47]">
              <span><b>{posts.length}</b> posts</span>
              <span><b>{followersCount}</b> followers</span>
              <span><b>{followingCount}</b> following</span>
            </div>

            {profile?.bio && <p className="mt-2 text-[#8B6F47]/80">{profile.bio}</p>}
          </div>
        </div>

        {/* POSTS GRID */}
        <div className="mt-6 grid grid-cols-2 md:grid-cols-3 gap-4">
          {posts.length === 0 ? (
            <div className="col-span-full text-center text-[#8B6F47]/70">No posts yet.</div>
          ) : (
            posts.map((p) => (
              <div key={p.id} className="bg-white/90 rounded-xl shadow overflow-hidden">
                {Array.isArray(p.images) && p.images[0] ? (
                  <img src={p.images[0]} alt="" className="w-full aspect-square object-cover" />
                ) : (
                  <div className="w-full aspect-square bg-[#F5F5F5]" />
                )}
                {p.text && <div className="px-3 py-2 text-sm text-[#8B6F47] line-clamp-2">{p.text}</div>}
              </div>
            ))
          )}
        </div>
      </div>
    </div>
  );
}









// src/pages/UserProfilePage.js
import React, { useEffect, useMemo, useState } from "react";
import { useParams, useNavigate } from "react-router-dom";
import { db } from "../firebase";
import { collection, doc, getDoc, getDocs, orderBy, query, where } from "firebase/firestore";
import { useAuth } from "../context/AuthContext";
import FollowButton from "../components/FollowButton";
import { useUserCounters } from "../hooks/useUserCounters";

export default function UserProfilePage() {
  const { uid } = useParams();                 // profile owner
  const { user: me } = useAuth();              // signed-in user
  const nav = useNavigate();

  const [profile, setProfile] = useState(null);
  const [posts, setPosts] = useState([]);

  // realtime counters maintained by Cloud Functions
  const { followersCount, followingCount } = useUserCounters(uid);

  const viewingOwn = me?.uid === uid;
  const name = useMemo(() => profile?.displayName || "User", [profile]);

  useEffect(() => {
    if (!uid) return;

    (async () => {
      // profile
      const p = await getDoc(doc(db, "users", uid));
      setProfile(p.exists() ? p.data() : { displayName: "User" });

      // posts by this user (newest first). If index missing, fallback without orderBy.
      try {
        const q1 = query(
          collection(db, "posts"),
          where("uid", "==", uid),
          orderBy("createdAt", "desc")
        );
        const ds = await getDocs(q1);
        setPosts(ds.docs.map((d) => ({ id: d.id, ...d.data() })));
      } catch {
        const q2 = query(collection(db, "posts"), where("uid", "==", uid));
        const ds = await getDocs(q2);
        setPosts(ds.docs.map((d) => ({ id: d.id, ...d.data() })));
      }
    })();
  }, [uid]);

  return (
    <div className="min-h-[calc(100vh-80px)] bg-[#FFE7CC]">
      <div className="max-w-5xl mx-auto px-4 py-6">
        <div className="bg-white/90 rounded-2xl shadow p-6 flex items-center gap-5">
          <img
            src={profile?.photoURL || "https://i.pravatar.cc/120?img=6"}
            className="w-20 h-20 rounded-full object-cover border"
            alt=""
          />

          <div className="flex-1">
            {/* HEADER ACTIONS */}
            <div className="flex items-center gap-3">
              <h1 className="text-2xl font-bold text-[#8B6F47]">{name}</h1>

              {viewingOwn ? (
                <>
                  <button
                    onClick={() => nav("/add-post")}
                    className="px-3 py-1.5 rounded-full bg-[#E2C299] text-white text-sm"
                  >
                    Create post
                  </button>
                  <button
                    onClick={() => nav("/settings")}
                    className="px-3 py-1.5 rounded-full bg-white border border-[#E2B887]/60 text-[#8B6F47] text-sm"
                  >
                    Edit profile
                  </button>
                </>
              ) : (
                <>
                  <FollowButton
                    me={{ uid: me?.uid, displayName: me?.displayName, photoURL: me?.photoURL }}
                    target={{ uid, displayName: profile?.displayName, photoURL: profile?.photoURL }}
                  />
                  <button
                    onClick={() => nav("/chat")}
                    className="px-3 py-1.5 rounded-full bg-[#FFE7CC] border border-[#E2B887]/60 text-[#8B6F47] text-sm"
                  >
                    Message
                  </button>
                </>
              )}
            </div>

            {/* COUNTS */}
            <div className="mt-1 flex gap-6 text-[#8B6F47]">
              <span><b>{posts.length}</b> posts</span>
              <span><b>{followersCount}</b> followers</span>
              <span><b>{followingCount}</b> following</span>
            </div>

            {profile?.bio && <p className="mt-2 text-[#8B6F47]/80">{profile.bio}</p>}
          </div>
        </div>

        {/* POSTS GRID */}
        <div className="mt-6 grid grid-cols-2 md:grid-cols-3 gap-4">
          {posts.length === 0 ? (
            <div className="col-span-full text-center text-[#8B6F47]/70">No posts yet.</div>
          ) : (
            posts.map((p) => (
              <div key={p.id} className="bg-white/90 rounded-xl shadow overflow-hidden">
                {Array.isArray(p.images) && p.images[0] ? (
                  <img src={p.images[0]} alt="" className="w-full aspect-square object-cover" />
                ) : (
                  <div className="w-full aspect-square bg-[#F5F5F5]" />
                )}
                {p.text && <div className="px-3 py-2 text-sm text-[#8B6F47] line-clamp-2">{p.text}</div>}
              </div>
            ))
          )}
        </div>
      </div>
    </div>
  );
}









import React, { useEffect, useMemo, useState } from "react";
import { useParams, useNavigate } from "react-router-dom";
import { db } from "../firebase";
import { collection, doc, getDoc, getDocs, orderBy, query, where } from "firebase/firestore";
import { useAuth } from "../context/AuthContext";
import { getAuth } from "firebase/auth";
import FollowButton from "../components/FollowButton";
import { useUserCounters } from "../hooks/useUserCounters";

export default function UserProfilePage() {
  const { uid } = useParams(); // target user id from /u/:uid
  const { user: me } = useAuth();
  const nav = useNavigate();
  const [profile, setProfile] = useState(null);
  const [posts, setPosts] = useState([]);
  const { followersCount, followingCount } = useUserCounters(uid);
  const auth = getAuth();

  const viewingOwn = me?.uid === uid;
  const name = useMemo(() => profile?.displayName || "User", [profile]);

  useEffect(() => {
    if (!uid) return;

    (async () => {
      // fetch profile
      const p = await getDoc(doc(db, "users", uid));
      setProfile(p.exists() ? p.data() : { displayName: "User" });

      // fetch posts by this user
      try {
        const q = query(
          collection(db, "posts"),
          where("uid", "==", uid),
          orderBy("createdAt", "desc")
        );
        const ds = await getDocs(q);
        setPosts(ds.docs.map((d) => ({ id: d.id, ...d.data() })));
      } catch {
        const q2 = query(collection(db, "posts"), where("uid", "==", uid));
        const ds = await getDocs(q2);
        setPosts(ds.docs.map((d) => ({ id: d.id, ...d.data() })));
      }
    })();
  }, [uid]);

  return (
    <div className="min-h-[calc(100vh-80px)] bg-[#FFE7CC]">
      <div className="max-w-5xl mx-auto px-4 py-6">
        <div className="bg-white/90 rounded-2xl shadow p-6 flex items-center gap-5">
          <img
            src={profile?.photoURL || "https://i.pravatar.cc/120?img=6"}
            className="w-20 h-20 rounded-full object-cover border"
            alt="User"
          />

          <div className="flex-1">
            {/* ---- HEADER BUTTONS ---- */}
            <div className="flex items-center gap-3">
              <h1 className="text-2xl font-bold text-[#8B6F47]">{name}</h1>

              {viewingOwn ? (
                <>
                  {/* Own profile — show create + edit buttons */}
                  <button
                    onClick={() => nav("/add-post")}
                    className="px-3 py-1.5 rounded-full bg-[#E2C299] text-white text-sm"
                  >
                    Create post
                  </button>
                  <button
                    onClick={() => nav("/settings")}
                    className="px-3 py-1.5 rounded-full bg-white border border-[#E2B887]/60 text-[#8B6F47] text-sm"
                  >
                    Edit profile
                  </button>
                </>
              ) : (
                <>
                  {/* Other user's profile — show follow + message */}
                  <FollowButton
                    me={{ uid: me?.uid, displayName: me?.displayName, photoURL: me?.photoURL }}
                    target={{ uid, displayName: profile?.displayName, photoURL: profile?.photoURL }}
                  />
                  <button
                    onClick={() => nav("/chat")}
                    className="px-3 py-1.5 rounded-full bg-[#FFE7CC] border border-[#E2B887]/60 text-[#8B6F47] text-sm"
                  >
                    Message
                  </button>
                </>
              )}
            </div>

            {/* ---- COUNTERS ---- */}
            <div className="mt-1 flex gap-6 text-[#8B6F47]">
              <span>
                <b>{posts.length}</b> posts
              </span>
              <span>
                <b>{followersCount}</b> followers
              </span>
              <span>
                <b>{followingCount}</b> following
              </span>
            </div>

            {profile?.bio && (
              <p className="mt-2 text-[#8B6F47]/80">{profile.bio}</p>
            )}
          </div>
        </div>

        {/* ---- POSTS ---- */}
        <div className="mt-6 grid grid-cols-2 md:grid-cols-3 gap-4">
          {posts.length === 0 ? (
            <div className="col-span-full text-center text-[#8B6F47]/70">
              No posts yet.
            </div>
          ) : (
            posts.map((p) => (
              <div
                key={p.id}
                className="bg-white/90 rounded-xl shadow overflow-hidden"
              >
                {Array.isArray(p.images) && p.images[0] ? (
                  <img
                    src={p.images[0]}
                    alt=""
                    className="w-full aspect-square object-cover"
                  />
                ) : (
                  <div className="w-full aspect-square bg-[#F5F5F5]" />
                )}
                {p.text && (
                  <div className="px-3 py-2 text-sm text-[#8B6F47] line-clamp-2">
                    {p.text}
                  </div>
                )}
              </div>
            ))
          )}
        </div>
      </div>
    </div>
  );
}




import React, { useEffect, useMemo, useState } from "react";
import { useParams, useNavigate } from "react-router-dom";
import { db } from "../firebase";
import { collection, doc, getDoc, getDocs, orderBy, query, where } from "firebase/firestore";
import { useAuth } from "../context/AuthContext";
import { getAuth } from "firebase/auth";
import FollowButton from "../components/FollowButton";
import { useUserCounters } from "../hooks/useUserCounters";

export default function UserProfilePage() {
  const { uid } = useParams(); // target user id from /u/:uid
  const { user: me } = useAuth();
  const nav = useNavigate();
  const [profile, setProfile] = useState(null);
  const [posts, setPosts] = useState([]);
  const { followersCount, followingCount } = useUserCounters(uid);

  const auth = getAuth();
  const viewingOwn = me?.uid === uid;
  
  console.log("AUTH ID = ", auth.currentUser?.uid);
  
  useEffect(() => {
    if (!uid) return;
    (async () => {
      const p = await getDoc(doc(db, "users", uid));
      setProfile(p.exists() ? p.data() : { displayName: "User" });

      // posts by this user
      try {
        const q1 = query(collection(db, "posts"), where("uid", "==", uid), orderBy("createdAt", "desc"));
        const ds = await getDocs(q1);
        setPosts(ds.docs.map((d) => ({ id: d.id, ...d.data() })));
      } catch {
        const q2 = query(collection(db, "posts"), where("uid", "==", uid));
        const ds = await getDocs(q2);
        setPosts(ds.docs.map((d) => ({ id: d.id, ...d.data() })));
      }

     
    })();
  }, [uid]);

  const name = useMemo(() => profile?.displayName || "User", [profile]);

  return (
    <div className="min-h-[calc(100vh-80px)] bg-[#FFE7CC]">
      <div className="max-w-5xl mx-auto px-4 py-6">
        <div className="bg-white/90 rounded-2xl shadow p-6 flex items-center gap-5">
          <img
            src={profile?.photoURL || "https://i.pravatar.cc/120?img=6"}
            className="w-20 h-20 rounded-full object-cover border"
          />
          <div className="flex-1">
            <div className="flex items-center gap-3">
              <h1 className="text-2xl font-bold text-[#8B6F47]">{name}</h1>
              {me && (
                <FollowButton
                  me={{ uid: me.uid, displayName: me.displayName, photoURL: me.photoURL }}
                  target={{ uid, displayName: profile?.displayName, photoURL: profile?.photoURL }}
                />
              )}
              <button
                onClick={() => nav("/chat")}
                className="px-3 py-1.5 rounded-full bg-[#FFE7CC] border border-[#E2B887]/60 text-[#8B6F47] text-sm"
              >
                Message
              </button>
            </div>
            <div className="mt-1 flex gap-6 text-[#8B6F47]">
              <span><b>{posts.length}</b> posts</span>
              <span><b>{followersCount}</b> followers</span>
              <span><b>{followersCount}</b> following</span>
            </div>
            {profile?.bio && <p className="mt-2 text-[#8B6F47]/80">{profile.bio}</p>}
          </div>
        </div>

        <div className="mt-6 grid grid-cols-2 md:grid-cols-3 gap-4">
          {posts.length === 0 ? (
            <div className="col-span-full text-center text-[#8B6F47]/70">No posts yet.</div>
          ) : (
            posts.map((p) => (
              <div key={p.id} className="bg-white/90 rounded-xl shadow overflow-hidden">
                {Array.isArray(p.images) && p.images[0] ? (
                  <img src={p.images[0]} alt="" className="w-full aspect-square object-cover" />
                ) : (
                  <div className="w-full aspect-square bg-[#F5F5F5]" />
                )}
                {p.text && <div className="px-3 py-2 text-sm text-[#8B6F47] line-clamp-2">{p.text}</div>}
              </div>
            ))
          )}
        </div>
      </div>
    </div>
  );
}








// src/components/FollowButton.jsx
import { useEffect, useState } from "react";
import { db } from "../firebase";
import { doc, onSnapshot, writeBatch, serverTimestamp } from "firebase/firestore";

export default function FollowButton({ me, target }) {
  const meUid = me?.uid;
  const targetUid = target?.uid;

  const [isFollowing, setIsFollowing] = useState(false);

  useEffect(() => {
    if (!meUid || !targetUid || meUid === targetUid) return;
    const ref = doc(db, "follows", meUid, "following", targetUid);
    return onSnapshot(ref, (snap) => setIsFollowing(snap.exists()));
  }, [meUid, targetUid]);

  // hide button on my own profile or if missing data
  if (!meUid || !targetUid || meUid === targetUid) return null;

  async function follow() {
    const batch = writeBatch(db);
    batch.set(
      doc(db, "follows", targetUid, "followers", meUid),
      { uid: meUid, displayName: me?.displayName || "", photoURL: me?.photoURL || "", createdAt: serverTimestamp() },
      { merge: true }
    );
    batch.set(
      doc(db, "follows", meUid, "following", targetUid),
      { uid: targetUid, displayName: target?.displayName || "", photoURL: target?.photoURL || "", createdAt: serverTimestamp() },
      { merge: true }
    );
    await batch.commit();
  }

  async function unfollow() {
    const batch = writeBatch(db);
    batch.delete(doc(db, "follows", targetUid, "followers", meUid));
    batch.delete(doc(db, "follows", meUid, "following", targetUid));
    await batch.commit();
  }

  return (
    <button
      onClick={isFollowing ? unfollow : follow}
      className={`px-4 py-1.5 rounded-full text-sm border transition
        ${isFollowing ? "bg-white text-[#8B6F47] border-[#E2B887]" : "bg-[#8B6F47] text-white border-[#8B6F47]"}`}
    >
      {isFollowing ? "Unfollow" : "Follow"}
    </button>
  );
}


import { useEffect, useState } from "react";
import { db } from "../firebase";
import { doc, onSnapshot, writeBatch, serverTimestamp } from "firebase/firestore";

export default function FollowButton({ me, target }) {
  const meUid = me?.uid;
  const targetUid = target?.uid;

  // 🧠 Hooks must always be declared before any condition or return
  const [isFollowing, setIsFollowing] = useState(false);

  // live listener — only run when both IDs exist and are different
  useEffect(() => {
    if (!meUid || !targetUid || meUid === targetUid) return;
    const ref = doc(db, "follows", meUid, "following", targetUid);
    const unsub = onSnapshot(ref, (snap) => setIsFollowing(snap.exists()));
    return unsub;
  }, [meUid, targetUid]);

  // hide button if it's my own profile
  if (!meUid || !targetUid || meUid === targetUid) return null;

  async function follow() {
    const batch = writeBatch(db);
    batch.set(
      doc(db, "follows", targetUid, "followers", meUid),
      {
        uid: meUid,
        displayName: me?.displayName || "",
        photoURL: me?.photoURL || "",
        createdAt: serverTimestamp(),
      },
      { merge: true }
    );
    batch.set(
      doc(db, "follows", meUid, "following", targetUid),
      {
        uid: targetUid,
        displayName: target?.displayName || "",
        photoURL: target?.photoURL || "",
        createdAt: serverTimestamp(),
      },
      { merge: true }
    );
    await batch.commit();
  }

  async function unfollow() {
    const batch = writeBatch(db);
    batch.delete(doc(db, "follows", targetUid, "followers", meUid));
    batch.delete(doc(db, "follows", meUid, "following", targetUid));
    await batch.commit();
  }

  return (
    <button
      onClick={isFollowing ? unfollow : follow}
      className={`px-4 py-1.5 rounded-full text-sm border transition
        ${isFollowing
          ? "bg-white text-[#8B6F47] border-[#E2B887]"
          : "bg-[#8B6F47] text-white border-[#8B6F47]"}`}
    >
      {isFollowing ? "Unfollow" : "Follow"}
    </button>
  );
}



import { useEffect, useState } from "react";
import { db } from "../firebase";
import { doc, onSnapshot, writeBatch, serverTimestamp } from "firebase/firestore";

export default function FollowButton({ me, target }) {
  const meUid = me?.uid;
  const targetUid = target?.uid;

  // hide on own profile or when data missing
  if (!meUid || !targetUid || meUid === targetUid) return null;

  const [isFollowing, setIsFollowing] = useState(false);

  // live status
  useEffect(() => {
    const ref = doc(db, "follows", meUid, "following", targetUid);
    return onSnapshot(ref, (snap) => setIsFollowing(snap.exists()));
  }, [meUid, targetUid]);

  async function follow() {
    const batch = writeBatch(db);
    // target’s followers
    batch.set(
      doc(db, "follows", targetUid, "followers", meUid),
      {
        uid: meUid,
        displayName: me?.displayName || "",
        photoURL: me?.photoURL || "",
        createdAt: serverTimestamp(),
      },
      { merge: true }
    );
    // my following
    batch.set(
      doc(db, "follows", meUid, "following", targetUid),
      {
        uid: targetUid,
        displayName: target?.displayName || "",
        photoURL: target?.photoURL || "",
        createdAt: serverTimestamp(),
      },
      { merge: true }
    );
    await batch.commit(); // Functions will add notification + bump counters
  }

  async function unfollow() {
    const batch = writeBatch(db);
    batch.delete(doc(db, "follows", targetUid, "followers", meUid));
    batch.delete(doc(db, "follows", meUid, "following", targetUid));
    await batch.commit();
  }

  return (
    <button
      onClick={isFollowing ? unfollow : follow}
      className={`px-4 py-1.5 rounded-full text-sm border transition
        ${isFollowing
          ? "bg-white text-[#8B6F47] border-[#E2B887]"
          : "bg-[#8B6F47] text-white border-[#8B6F47]"}`}
    >
      {isFollowing ? "Unfollow" : "Follow"}
    </button>
  );
}


// src/services/chatApi.js
import {
  doc, setDoc, getDoc, serverTimestamp, addDoc,
  collection, query, where, onSnapshot, orderBy, limit, updateDoc
} from "firebase/firestore";
import { db } from "../firebase";

// Stable 1:1 chat id (sorted uids)
export function directChatId(a, b) {
  return [a, b].sort().join("_");
}

/** Ensure chat doc exists with participants[] and return {id, ref} */
export async function ensureDirectChat(meUid, otherUid) {
  const id = directChatId(meUid, otherUid);
  const ref = doc(db, "chats", id);
  const snap = await getDoc(ref);
  if (!snap.exists()) {
    await setDoc(ref, {
      participants: [meUid, otherUid],
      createdAt: serverTimestamp(),
      lastMessageText: "",
      lastMessageAt: serverTimestamp(),
      typing: {},                // map of uid -> boolean
      lastSeen: {},              // map of uid -> Timestamp
      type: "direct",
    }, { merge: true });
  }
  return { id, ref };
}

/** Send a text message and update chat preview */
export async function sendMessage(chatId, { senderId, text }) {
  const msgRef = await addDoc(collection(db, "chats", chatId, "messages"), {
    senderId,
    text: text || "",
    imageUrl: null,
    createdAt: serverTimestamp(),
    // no per-message seen list needed when we track chat.lastSeen
  });
  await updateDoc(doc(db, "chats", chatId), {
    lastMessageText: text ? String(text).slice(0, 90) : "New message",
    lastMessageAt: serverTimestamp(),
  });
  return msgRef.id;
}

/** Send an image message (url already uploaded) */
export async function sendImageMessage(chatId, { senderId, imageUrl }) {
  const msgRef = await addDoc(collection(db, "chats", chatId, "messages"), {
    senderId,
    text: "",
    imageUrl,
    createdAt: serverTimestamp(),
  });
  await updateDoc(doc(db, "chats", chatId), {
    lastMessageText: "📷 Photo",
    lastMessageAt: serverTimestamp(),
  });
  return msgRef.id;
}

/** Live stream of messages in a chat (ascending) */
export function listenMessages(chatId, cb, pageSize = 50) {
  const q = query(
    collection(db, "chats", chatId, "messages"),
    orderBy("createdAt", "asc"),
    limit(pageSize)
  );
  return onSnapshot(q, (snap) => cb(snap.docs.map(d => ({ id: d.id, ...d.data() }))));
}

/** My chats list (ordered by lastMessageAt desc) */
export function listenMyChats(meUid, cb) {
  if (!meUid) return () => {};
  const q = query(
    collection(db, "chats"),
    where("participants", "array-contains", meUid),
    orderBy("lastMessageAt", "desc")
  );
  return onSnapshot(q, (snap) => cb(snap.docs.map(d => ({ id: d.id, ...d.data() }))));
}

/** Mark me as typing / not typing */
export async function setTyping(chatId, meUid, isTyping) {
  await updateDoc(doc(db, "chats", chatId), { [`typing.${meUid}`]: !!isTyping });
}

/** Update my lastSeen timestamp for this chat */
export async function setLastSeen(chatId, meUid) {
  await updateDoc(doc(db, "chats", chatId), { [`lastSeen.${meUid}`]: serverTimestamp() });
}





......




// src/pages/ChatPage.js
import React, { useEffect, useMemo, useRef, useState } from "react";
import { useAuth } from "../context/AuthContext";
import { db, storage } from "../firebase";
import { collection, doc, getDocs, onSnapshot } from "firebase/firestore";
import { ref as sref, uploadBytes, getDownloadURL } from "firebase/storage";
import {
  directChatId,
  ensureDirectChat,
  listenMessages,
  listenMyChats,
  sendMessage,
  sendImageMessage,
  setTyping,
  setLastSeen,
} from "../services/chatApi";

const formatTime = (ts) =>
  ts ? new Date(ts).toLocaleTimeString([], { hour: "numeric", minute: "2-digit" }) : "";

const debounce = (fn, ms = 800) => {
  let t;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...args), ms);
  };
};

export default function ChatPage() {
  const { user } = useAuth();
  const me = user?.uid;

  const [allUsers, setAllUsers] = useState([]);
  const [chatList, setChatList] = useState([]);
  const [other, setOther] = useState(null);
  const [chatId, setChatId] = useState(null);
  const [messages, setMessages] = useState([]);
  const [typingIndicator, setTypingIndicator] = useState(false);

  const [text, setText] = useState("");
  const [pendingImage, setPendingImage] = useState(null);
  const [pendingURL, setPendingURL] = useState("");
  const endRef = useRef(null);

  // Load users (simple directory)
  useEffect(() => {
    if (!me) return;
    (async () => {
      const snap = await getDocs(collection(db, "users"));
      const list = snap.docs.map(d => ({ id: d.id, ...d.data() })).filter(u => u.uid !== me);
      setAllUsers(list);
    })();
  }, [me]);

  // My chat list
  useEffect(() => {
    if (!me) return;
    return listenMyChats(me, setChatList);
  }, [me]);

  // Open chat with another user (ensures chat doc exists)
  async function openChatWith(targetUser) {
    if (!me || !targetUser?.uid) return;
    setOther(targetUser);
    const { id } = await ensureDirectChat(me, targetUser.uid);
    setChatId(id);
    await setLastSeen(id, me);                 // mark seen immediately
  }

  // Live messages in active chat
  useEffect(() => {
    if (!chatId) return;
    const unsub = listenMessages(chatId, (rows) => {
      setMessages(rows);
      // scroll to bottom
      setTimeout(() => endRef.current?.scrollIntoView({ behavior: "smooth" }), 0);
      // update my lastSeen on every new message
      if (me) setLastSeen(chatId, me).catch(() => {});
    });
    return unsub;
  }, [chatId, me]);

  // Typing indicator from chat doc
  useEffect(() => {
    if (!chatId || !me) return;
    const unsub = onSnapshot(doc(db, "chats", chatId), (snap) => {
      const typing = snap.data()?.typing || {};
      const someoneElseTyping = Object.entries(typing).some(([uid, val]) => uid !== me && val);
      setTypingIndicator(someoneElseTyping);
    });
    return unsub;
  }, [chatId, me]);

  const stopTypingDebounced = useMemo(
    () => debounce(() => chatId && me && setTyping(chatId, me, false), 1000),
    [chatId, me]
  );

  // Compute "Seen" using chat.lastSeen[otherUid] >= msg.createdAt
  const otherSeenMap = useMemo(() => {
    // subscribe to chat doc to read lastSeen map
    // (reuse the same snapshot from typing effect)
    return null;
  }, [chatId]);

  async function handleSend(e) {
    e?.preventDefault?.();
    if (!text.trim() || !chatId || !me) return;
    await sendMessage(chatId, { senderId: me, text: text.trim() });
    setText("");
    await setTyping(chatId, me, false);
  }

  async function handleImageSend(file) {
    if (!file || !chatId || !me) return;
    const path = `chats/${chatId}/${me}/${Date.now()}_${file.name}`;
    const r = sref(storage, path);
    await uploadBytes(r, file);
    const url = await getDownloadURL(r);
    await sendImageMessage(chatId, { senderId: me, imageUrl: url });
  }

  return (
    <div className="flex h-[calc(100vh-80px)] bg-white rounded-2xl shadow overflow-hidden">
      {/* Left: users + my chats */}
      <div className="w-1/3 border-r border-[#E2B887]/30 p-4 overflow-y-auto">
        <h2 className="text-lg font-bold text-[#8B6F47] mb-3">Messages</h2>

        {/* People directory */}
        <div className="mb-4">
          <div className="text-xs text-[#8B6F47]/60 mb-1">Start new chat</div>
          <ul className="space-y-1">
            {allUsers.map(u => (
              <li key={u.uid}>
                <button
                  onClick={() => openChatWith(u)}
                  className="w-full flex items-center gap-2 p-2 rounded hover:bg-[#FFF4E6]"
                >
                  <img src={u.photoURL || "https://i.pravatar.cc/48?img=1"} className="w-8 h-8 rounded-full object-cover" />
                  <span className="text-sm text-[#8B6F47]">{u.displayName || u.email}</span>
                </button>
              </li>
            ))}
          </ul>
        </div>

        {/* My recent chats */}
        <div>
          <div className="text-xs text-[#8B6F47]/60 mb-1">Recent</div>
          <ul className="space-y-1">
            {chatList.map(c => {
              const others = (c.participants || []).filter(id => id !== me).join(", ");
              return (
                <li key={c.id}>
                  <button
                    onClick={() => openChatWith({ uid: directChatId(...(c.participants || [])).replace(`${me}_`, "").replace(`_${me}`, "") })} // best-effort
                    className={`w-full text-left p-2 rounded hover:bg-[#FFF4E6] ${c.id === chatId ? "bg-[#FFF4E6]" : ""}`}
                  >
                    <div className="text-sm text-[#8B6F47]">{others || "Chat"}</div>
                    <div className="text-xs text-[#8B6F47]/60">{c.lastMessageText || ""}</div>
                  </button>
                </li>
              );
            })}
          </ul>
        </div>
      </div>

      {/* Right: active chat */}
      <div className="w-2/3 flex flex-col">
        {other ? (
          <>
            <div className="bg-[#F5F5F5] p-4 border-b border-[#E2B887]/30 flex items-center gap-3">
              <img
                src={other.photoURL || "https://i.pravatar.cc/40?img=2"}
                className="w-10 h-10 rounded-full object-cover"
              />
              <h3 className="text-xl font-bold text-[#8B6F47]">
                {other.displayName || other.email || "User"}
              </h3>
              {typingIndicator && <span className="text-xs text-[#8B6F47]/70 ml-2">typing…</span>}
            </div>

            <div className="flex-1 p-4 overflow-y-auto space-y-4">
              {messages.length === 0 ? (
                <p className="text-center text-[#8B6F47]/60">Start a conversation!</p>
              ) : (
                messages.map((m) => (
                  <div key={m.id} className={`flex ${m.senderId === me ? "justify-end" : "justify-start"}`}>
                    <div className={`max-w-[70%] p-3 rounded-xl ${m.senderId === me ? "bg-[#E2B887] text-white" : "bg-[#F5F5F5] text-[#8B6F47]"}`}>
                      {m.imageUrl ? (
                        <img src={m.imageUrl} className="rounded-lg w-full max-w-[220px] object-cover" />
                      ) : (
                        <p>{m.text}</p>
                      )}
                      <span className="text-xs opacity-70 mt-1 block">
                        {formatTime(m.createdAt?.toDate?.() || m.createdAt)}
                      </span>
                    </div>
                  </div>
                ))
              )}
              <div ref={endRef} />
            </div>

            {/* pending image preview */}
            {pendingImage && (
              <div className="px-4 pt-3 pb-2 border-t border-[#E2B887]/30 bg-[#FFF8EF] flex items-center gap-3 justify-between">
                <img src={pendingURL} className="w-20 h-20 rounded-lg object-cover border shadow-sm" />
                <div className="flex gap-2">
                  <button
                    onClick={async () => {
                      const f = pendingImage;
                      setPendingImage(null); setPendingURL("");
                      await handleImageSend(f);
                    }}
                    className="px-4 py-2 bg-[#E2B887] text-white rounded-lg hover:bg-[#D4A77C]"
                  >
                    Send
                  </button>
                  <button
                    onClick={() => {
                      if (pendingURL) URL.revokeObjectURL(pendingURL);
                      setPendingImage(null); setPendingURL("");
                    }}
                    className="px-4 py-2 border border-[#E2B887]/60 rounded-lg text-[#8B6F47] hover:bg-[#FFF1DF]"
                  >
                    Cancel
                  </button>
                </div>
              </div>
            )}

            {/* composer */}
            <form
              onSubmit={async (e) => { e.preventDefault(); await handleSend(); }}
              className="p-4 border-t border-[#E2B887]/30 flex items-center gap-3"
            >
              <input
                className="flex-1 p-3 border border-[#E2B887]/50 rounded-lg focus:outline-none focus:ring-2 focus:ring-[#E2B887] text-[#8B6F47] placeholder-[#8B6F47]/50"
                placeholder="Type a message…"
                value={text}
                onChange={(e) => {
                  setText(e.target.value);
                  if (chatId && me) { setTyping(chatId, me, true).catch(()=>{}); stopTypingDebounced(); }
                }}
              />
              <input
                type="file"
                accept="image/*"
                id="chat-file"
                className="hidden"
                onChange={(e) => {
                  const f = e.target.files?.[0]; if (!f) return;
                  setPendingImage(f);
                  setPendingURL(URL.createObjectURL(f));
                }}
              />
              <label htmlFor="chat-file" className="cursor-pointer bg-[#FFE7CC] text-[#8B6F47] px-3 py-3 rounded-full border border-[#E2B887]/60">📷</label>
              <button className="bg-[#E2B887] text-white px-4 py-3 rounded-full hover:bg-[#D4A77C]">Send</button>
            </form>
          </>
        ) : (
          <div className="w-full h-full grid place-items-center text-[#8B6F47]/60">
            Select a chat to start messaging
          </div>
        )}
      </div>
    </div>
  );
}




// src/pages/ChatPage.js
import React, { useEffect, useMemo, useRef, useState } from "react";
import { useAuth } from "../context/AuthContext";
import { db } from "../firebase";
import {
  collection,
  doc,
  getDocs,
  onSnapshot,
  orderBy,
  query,
  serverTimestamp,
  setDoc,
  addDoc,
  updateDoc,
  where,
  writeBatch,
} from "firebase/firestore";
import { Send } from "lucide-react";
import { storage } from "../firebase";
import { getDownloadURL, ref as sref, uploadBytes } from "firebase/storage";

// helpers
const chatIdFor = (a, b) => [a, b].sort().join("_");
const debounce = (fn, ms = 600) => {
  let t;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...args), ms);
  };
};
const formatTime = (d) =>
  d ? new Date(d).toLocaleTimeString([], { hour: "numeric", minute: "2-digit" }) : "";

export default function ChatPage() {
  const { user } = useAuth();

  const [allUsers, setAllUsers] = useState([]);
  const [selectedChatUser, setSelectedChatUser] = useState(null);
  const [activeChatId, setActiveChatId] = useState(null);
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState("");
  const messagesEndRef = useRef(null);
  const [isOtherTyping, setIsOtherTyping] = useState(false);

  // Image preview
  const [pendingImage, setPendingImage] = useState(null);
  const [pendingURL, setPendingURL] = useState("");

  // load users (exclude me)
  useEffect(() => {
    if (!user) return;
    (async () => {
      const snap = await getDocs(collection(db, "users"));
      const list = snap.docs
        .map((d) => ({ id: d.id, ...d.data() }))
        .filter((u) => u.uid !== user.uid);
      setAllUsers(list);
    })();
  }, [user]);

  // ensure chat + open
  async function openChatWith(other) {
    if (!user || !other?.uid) return;

    const id = chatIdFor(user.uid, other.uid);
    setSelectedChatUser(other);
    setActiveChatId(id);

    await setDoc(
      doc(db, "chats", id),
      {
        members: [user.uid, other.uid],
        createdAt: serverTimestamp(),
        lastMessage: "",
        lastMessageAt: serverTimestamp(),
      },
      { merge: true }
    );

    markSeen(id, user.uid).catch(() => {});
  }

  // live messages
  useEffect(() => {
    if (!activeChatId) return;

    const q = query(
      collection(db, "chats", activeChatId, "messages"),
      orderBy("createdAt", "asc")
    );

    const unsub = onSnapshot(q, (snap) => {
      const rows = snap.docs.map((d) => {
        const data = d.data();
        return {
          id: d.id,
          ...data,
          _ts: data.createdAt?.toDate ? data.createdAt.toDate() : new Date(),
          seenBy: Array.isArray(data.seenBy) ? data.seenBy : [],
        };
      });
      setMessages(rows);

      setTimeout(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
      }, 0);

      if (activeChatId && user) {
        markSeen(activeChatId, user.uid).catch(() => {});
      }
    });

    return unsub;
  }, [activeChatId, user]);

  // listen typing
  useEffect(() => {
    if (!activeChatId || !user) return;
    const chatRef = doc(db, "chats", activeChatId);
    const unsub = onSnapshot(chatRef, (snap) => {
      const typing = snap.data()?.typing || {};
      const otherTyping = Object.keys(typing).some(
        (uid) => uid !== user.uid && typing[uid] === true
      );
      setIsOtherTyping(otherTyping);
    });
    return unsub;
  }, [activeChatId, user]);

  // mark seen
  async function markSeen(chatId, myUid) {
    const msgsQ = query(
      collection(db, "chats", chatId, "messages"),
      where("senderId", "!=", myUid)
    );
    const snap = await getDocs(msgsQ);
    if (snap.empty) return;

    const batch = writeBatch(db);
    snap.forEach((d) => {
      const data = d.data();
      const seenBy = Array.isArray(data.seenBy) ? data.seenBy : [];
      if (!seenBy.includes(myUid)) {
        batch.update(d.ref, { seenBy: [...seenBy, myUid] });
      }
    });
    await batch.commit();
  }

  // send text
  async function handleSendMessage(e) {
    e?.preventDefault?.();
    if (!newMessage.trim() || !activeChatId || !user) return;

    const text = newMessage.trim();
    setNewMessage("");

    updateDoc(doc(db, "chats", activeChatId), {
      [`typing.${user.uid}`]: false,
    }).catch(() => {});

    await addDoc(collection(db, "chats", activeChatId, "messages"), {
      senderId: user.uid,
      text,
      createdAt: serverTimestamp(),
      seenBy: [user.uid],
    });

    await updateDoc(doc(db, "chats", activeChatId), {
      lastMessage: text,
      lastMessageAt: serverTimestamp(),
    });
  }

  // send image
  async function handleSendImage(file) {
    if (!file || !activeChatId || !user) return;

    const path = `chats/${activeChatId}/${user.uid}/${Date.now()}_${file.name}`;
    const r = sref(storage, path);
    await uploadBytes(r, file);
    const url = await getDownloadURL(r);

    await addDoc(collection(db, "chats", activeChatId, "messages"), {
      senderId: user.uid,
      imageUrl: url,
      createdAt: serverTimestamp(),
      seenBy: [user.uid],
    });

    await updateDoc(doc(db, "chats", activeChatId), {
      lastMessage: "📷 Photo",
      lastMessageAt: serverTimestamp(),
    });
  }

  const debouncedStopTyping = useMemo(
    () =>
      debounce(() => {
        if (activeChatId && user) {
          updateDoc(doc(db, "chats", activeChatId), {
            [`typing.${user.uid}`]: false,
          }).catch(() => {});
        }
      }, 1000),
    [activeChatId, user]
  );

  // render
  return (
    <div className="flex h-[calc(100vh-80px)] bg-white rounded-2xl shadow overflow-hidden">
      {/* Left list */}
      <div className="w-1/3 border-r border-[#E2B887]/30 p-4 overflow-y-auto">
        <h2 className="text-lg font-bold text-[#8B6F47] mb-3">Messages</h2>
        {allUsers.length === 0 ? (
          <p className="text-[#8B6F47]/60">No other users yet.</p>
        ) : (
          <ul className="space-y-2">
            {allUsers.map((u) => (
              <li key={u.uid}>
                <button
                  onClick={() => openChatWith(u)}
                  className={`w-full flex items-center gap-3 p-2 rounded-lg hover:bg-[#FFF4E6] transition ${
                    selectedChatUser?.uid === u.uid ? "bg-[#FFF4E6]" : ""
                  }`}
                >
                  <img
                    src={u.photoURL || "https://i.pravatar.cc/48?img=1"}
                    alt={u.displayName || u.email || "user"}
                    className="w-10 h-10 rounded-full object-cover"
                  />
                  <div className="text-left">
                    <div className="text-[#8B6F47] font-semibold">
                      {u.displayName || u.email}
                    </div>
                    <div className="text-xs text-[#8B6F47]/60">{u.email}</div>
                  </div>
                </button>
              </li>
            ))}
          </ul>
        )}
      </div>

      {/* Right: chat */}
      <div className="w-2/3 flex flex-col">
        {selectedChatUser ? (
          <>
            <div className="bg-[#F5F5F5] p-4 border-b border-[#E2B887]/30 flex items-center space-x-3">
              <img
                src={selectedChatUser.photoURL || "https://i.pravatar.cc/40?img=2"}
                alt={selectedChatUser.displayName || selectedChatUser.petName || "user"}
                className="w-10 h-10 rounded-full object-cover"
              />
              <h3 className="text-xl font-bold text-[#8B6F47]">
                {selectedChatUser.petName ||
                  selectedChatUser.displayName ||
                  selectedChatUser.email}
              </h3>
              {isOtherTyping && (
                <span className="text-xs text-[#8B6F47]/70 ml-2">typing…</span>
              )}
            </div>

            <div className="flex-1 p-4 overflow-y-auto space-y-4">
              {messages.length === 0 ? (
                <p className="text-center text-[#8B6F47]/60">Start a conversation!</p>
              ) : (
                messages.map((msg) => (
                  <div
                    key={msg.id}
                    className={`flex ${
                      msg.senderId === user.uid ? "justify-end" : "justify-start"
                    }`}
                  >
                    <div
                      className={`max-w-[70%] p-3 rounded-xl ${
                        msg.senderId === user.uid
                          ? "bg-[#E2B887] text-white"
                          : "bg-[#F5F5F5] text-[#8B6F47]"
                      }`}
                    >
                      {msg.imageUrl ? (
                        <img
                          src={msg.imageUrl}
                          alt="sent"
                          className="rounded-lg w-full max-w-[200px] object-cover"
                        />
                      ) : (
                        <p>{msg.text}</p>
                      )}

                      <span className="text-xs opacity-70 mt-1 block">
                        {formatTime(msg._ts)}
                      </span>

                      {msg.senderId === user.uid &&
                        Array.isArray(msg.seenBy) &&
                        msg.seenBy.length > 1 && (
                          <span className="text-[10px] opacity-70 mt-1 block text-right">
                            Seen
                          </span>
                        )}
                    </div>
                  </div>
                ))
              )}
              <div ref={messagesEndRef} />
            </div>

            {pendingImage && (
              <div className="px-4 pt-3 pb-2 border-t border-[#E2B887]/30 bg-[#FFF8EF] flex items-center gap-3 justify-between">
                <img
                  src={pendingURL}
                  alt="preview"
                  className="w-20 h-20 rounded-lg object-cover border shadow-sm"
                />
                <div className="flex gap-2">
                  <button
                    onClick={async () => {
                      const f = pendingImage;
                      setPendingImage(null);
                      setPendingURL("");
                      await handleSendImage(f);
                    }}
                    className="px-4 py-2 bg-[#E2B887] text-white rounded-lg hover:bg-[#D4A77C]"
                  >
                    Send
                  </button>
                  <button
                    onClick={() => {
                      if (pendingURL) URL.revokeObjectURL(pendingURL);
                      setPendingImage(null);
                      setPendingURL("");
                    }}
                    className="px-4 py-2 border border-[#E2B887]/60 rounded-lg text-[#8B6F47] hover:bg-[#FFF1DF]"
                  >
                    Cancel
                  </button>
                </div>
              </div>
            )}

            <form
              onSubmit={handleSendMessage}
              className="p-4 border-t border-[#E2B887]/30 flex items-center space-x-3"
            >
              <input
                type="text"
                value={newMessage}
                onChange={(e) => {
                  setNewMessage(e.target.value);
                  if (activeChatId && user) {
                    updateDoc(doc(db, "chats", activeChatId), {
                      [`typing.${user.uid}`]: true,
                    }).catch(() => {});
                    debouncedStopTyping();
                  }
                }}
                placeholder="Type a message..."
                className="flex-1 p-3 border border-[#E2B887]/50 rounded-lg focus:outline-none focus:ring-2 focus:ring-[#E2B887] text-[#8B6F47] placeholder-[#8B6F47]/50"
              />
              <input
                type="file"
                accept="image/*"
                onChange={(e) => {
                  const f = e.target.files?.[0];
                  if (!f) return;
                  setPendingImage(f);
                  const url = URL.createObjectURL(f);
                  setPendingURL(url);
                }}
                className="hidden"
                id="chat-upload"
              />
              <label
                htmlFor="chat-upload"
                className="cursor-pointer bg-[#FFE7CC] text-[#8B6F47] px-3 py-3 rounded-full border border-[#E2B887]/60"
                title="Send photo"
              >
                📷
              </label>
              <button
                type="submit"
                className="bg-[#E2B887] text-white p-3 rounded-full hover:bg-[#D4A77C] transition-colors"
                title="Send"
              >
                <Send className="w-6 h-6" />
              </button>
            </form>
          </>
        ) : (
          <div className="flex-1 flex items-center justify-center text-center text-[#8B6F47]/60">
            <p className="text-xl">Select a chat to start messaging</p>
          </div>
        )}
      </div>
    </div>
  );
}


import {
  doc, getDoc, setDoc, serverTimestamp,
  collection, query, where, orderBy, onSnapshot, addDoc, updateDoc
} from "firebase/firestore";
import { db } from "../firebase";

const chatIdFor = (a, b) => [a, b].sort().join("_");

/** Ensure a 1:1 chat exists and return {id, ref} */
export async function ensureChat(uidA, uidB) {
  const id = chatIdFor(uidA, uidB);
  const ref = doc(db, "chats", id);
  const snap = await getDoc(ref);
  if (!snap.exists()) {
    await setDoc(ref, {
      members: [uidA, uidB],
      createdAt: serverTimestamp(),
      lastMessage: "",
      lastMessageAt: serverTimestamp(),
    });
  }
  return { id, ref };
}

/** Live list of chats for a user (ordered by lastMessageAt desc) */
export function listenToMyChats(uid, cb) {
  const q = query(
    collection(db, "chats"),
    where("members", "array-contains", uid),
    orderBy("lastMessageAt", "desc")
  );
  return onSnapshot(q, (snap) => {
    cb(snap.docs.map(d => ({ id: d.id, ...d.data() })));
  });
}

/** Live messages in a chat (ascending by time) */
export function listenToMessages(chatId, cb) {
  const q = query(
    collection(db, "chats", chatId, "messages"),
    orderBy("createdAt", "asc")
  );
  return onSnapshot(q, (snap) => {
    cb(snap.docs.map(d => ({ id: d.id, ...d.data() })));
  });
}

/** Send a message and update chat preview */
export async function sendMessage(chatId, senderId, text) {
  const msgRef = await addDoc(collection(db, "chats", chatId, "messages"), {
    senderId,
    text,
    createdAt: serverTimestamp(),
  });
  await updateDoc(doc(db, "chats", chatId), {
    lastMessage: text,
    lastMessageAt: serverTimestamp(),
  });
  return msgRef.id;
}




// src/pages/NotificationsPage.js
import { useEffect, useState } from "react";
import { useAuth } from "../context/AuthContext";
import { listenNotifications, markNotifRead, markAllRead } from "../services/notificationsApi";
import { useNavigate } from "react-router-dom";

export default function NotificationsPage() {
  const { user } = useAuth();
  const [items, setItems] = useState([]);
  const nav = useNavigate();

  useEffect(() => {
    if (!user?.uid) return;
    return listenNotifications(user.uid, setItems);
  }, [user?.uid]);

  return (
    <div className="max-w-3xl mx-auto p-4">
      <div className="flex justify-between mb-3">
        <h2 className="text-xl font-semibold">Notifications</h2>
        <button
          className="text-sm text-blue-600"
          onClick={() => markAllRead(user.uid, items)}
        >Mark all read</button>
      </div>

      {items.length === 0 && <p className="text-gray-500">No notifications yet.</p>}

      <ul className="space-y-2">
        {items.map(n => (
          <li
            key={n.id}
            className={`p-3 rounded border ${n.isRead ? "bg-white" : "bg-yellow-50"}`}
          >
            <div className="flex gap-3 items-center">
              {n.actor?.avatar && <img src={n.actor.avatar} alt="" className="w-8 h-8 rounded-full" />}
              <div className="flex-1">
                <div className="text-sm">
                  <b>{n.actor?.name || "Someone"}</b> — {n.message}
                </div>
                <div className="text-xs text-gray-500">{n.type}</div>
              </div>
              {!n.isRead && (
                <button
                  className="text-xs text-blue-600"
                  onClick={() => markNotifRead(user.uid, n.id)}
                >
                  mark read
                </button>
              )}
              {n.url && (
                <button
                  className="text-xs text-green-700"
                  onClick={() => nav(n.url)}
                >
                  open
                </button>
              )}
            </div>
          </li>
        ))}
      </ul>
    </div>
  );
}






import { collection, query, orderBy, where, onSnapshot, doc, updateDoc } from "firebase/firestore";
import { db } from "../firebase";

// Live stream of notifications (newest first)
export function listenNotifications(uid, cb) {
  if (!uid) return () => {};
  const q = query(
    collection(db, "notifications", uid, "items"),
    orderBy("createdAt", "desc")
  );
  return onSnapshot(q, (snap) => cb(snap.docs.map(d => ({ id: d.id, ...d.data() }))));
}

// Unread counter for navbar badge
export function listenUnreadCount(uid, cb) {
  if (!uid) return () => {};
  const q = query(
    collection(db, "notifications", uid, "items"),
    where("isRead", "==", false)
  );
  return onSnapshot(q, (snap) => cb(snap.size));
}

// Mark a single notification as read
export async function markNotifRead(uid, id) {
  await updateDoc(doc(db, "notifications", uid, "items", id), { isRead: true });
}

// Mark all currently visible items as read (optional helper)
export async function markAllRead(uid, items) {
  const updates = items.map(n =>
    updateDoc(doc(db, "notifications", uid, "items", n.id), { isRead: true })
  );
  await Promise.allSettled(updates);
}







import { initializeApp, getApps, getApp } from "firebase/app";
import { 
  getAuth 
} from "firebase/auth";
import { 
  initializeFirestore, 
  persistentLocalCache, 
  persistentMultipleTabManager 
} from "firebase/firestore";
import { 
  getStorage 
} from "firebase/storage";

// --- Firebase Config ---
const firebaseConfig = {
  apiKey: process.env.REACT_APP_FIREBASE_API_KEY,
  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,
  storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.REACT_APP_FIREBASE_APP_ID,
};

// --- Initialize app ---
const app = getApps().length ? getApp() : initializeApp(firebaseConfig);

// --- Auth ---
export const auth = getAuth(app);

// --- Firestore (with local caching + multi-tab sync) ---
export const db = initializeFirestore(app, {
  localCache: persistentLocalCache({
    tabManager: persistentMultipleTabManager(),
  }),
});

// --- Storage ---
export const storage = getStorage(app);



import React, { useEffect, useMemo, useState } from "react";
import { useParams, useNavigate } from "react-router-dom";
import { db } from "../firebase";
import { collection, doc, getDoc, getDocs, orderBy, query, where } from "firebase/firestore";
import { useAuth } from "../context/AuthContext";
import FollowButton from "../components/FollowButton";
import { getFollowCounts } from "../services/socialApi";
import { getAuth } from "firebase/auth";

export default function UserProfilePage() {
  const { uid } = useParams(); // target user id from /u/:uid
  const { user: me } = useAuth();
  const nav = useNavigate();

  const [profile, setProfile] = useState(null);
  const [posts, setPosts] = useState([]);
  const [counts, setCounts] = useState({ followers: 0, following: 0 });

  const auth = getAuth();
  console.log("AUTH ID = ", auth.currentUser?.uid);
  
  useEffect(() => {
    if (!uid) return;
    (async () => {
      const p = await getDoc(doc(db, "users", uid));
      setProfile(p.exists() ? p.data() : { displayName: "User" });

      // posts by this user
      try {
        const q1 = query(collection(db, "posts"), where("uid", "==", uid), orderBy("createdAt", "desc"));
        const ds = await getDocs(q1);
        setPosts(ds.docs.map((d) => ({ id: d.id, ...d.data() })));
      } catch {
        const q2 = query(collection(db, "posts"), where("uid", "==", uid));
        const ds = await getDocs(q2);
        setPosts(ds.docs.map((d) => ({ id: d.id, ...d.data() })));
      }

      // counts
      const { followersCount, followingCount } = await getFollowCounts(uid);
      setCounts({ followers: followersCount, following: followingCount });
    })();
  }, [uid]);

  const name = useMemo(() => profile?.displayName || "User", [profile]);

  return (
    <div className="min-h-[calc(100vh-80px)] bg-[#FFE7CC]">
      <div className="max-w-5xl mx-auto px-4 py-6">
        <div className="bg-white/90 rounded-2xl shadow p-6 flex items-center gap-5">
          <img
            src={profile?.photoURL || "https://i.pravatar.cc/120?img=6"}
            className="w-20 h-20 rounded-full object-cover border"
          />
          <div className="flex-1">
            <div className="flex items-center gap-3">
              <h1 className="text-2xl font-bold text-[#8B6F47]">{name}</h1>
              {me && (
                <FollowButton
                  me={{ uid: me.uid, displayName: me.displayName, photoURL: me.photoURL }}
                  target={{ uid, displayName: profile?.displayName, photoURL: profile?.photoURL }}
                />
              )}
              <button
                onClick={() => nav("/chat")}
                className="px-3 py-1.5 rounded-full bg-[#FFE7CC] border border-[#E2B887]/60 text-[#8B6F47] text-sm"
              >
                Message
              </button>
            </div>
            <div className="mt-1 flex gap-6 text-[#8B6F47]">
              <span><b>{posts.length}</b> posts</span>
              <span><b>{counts.followers}</b> followers</span>
              <span><b>{counts.following}</b> following</span>
            </div>
            {profile?.bio && <p className="mt-2 text-[#8B6F47]/80">{profile.bio}</p>}
          </div>
        </div>

        <div className="mt-6 grid grid-cols-2 md:grid-cols-3 gap-4">
          {posts.length === 0 ? (
            <div className="col-span-full text-center text-[#8B6F47]/70">No posts yet.</div>
          ) : (
            posts.map((p) => (
              <div key={p.id} className="bg-white/90 rounded-xl shadow overflow-hidden">
                {Array.isArray(p.images) && p.images[0] ? (
                  <img src={p.images[0]} alt="" className="w-full aspect-square object-cover" />
                ) : (
                  <div className="w-full aspect-square bg-[#F5F5F5]" />
                )}
                {p.text && <div className="px-3 py-2 text-sm text-[#8B6F47] line-clamp-2">{p.text}</div>}
              </div>
            ))
          )}
        </div>
      </div>
    </div>
  );
}





// functions/index.js — Firebase Functions v2

const { setGlobalOptions } = require("firebase-functions/v2");
const { onDocumentCreated, onDocumentDeleted } = require("firebase-functions/v2/firestore");
const { initializeApp } = require("firebase-admin/app");
const { getFirestore, FieldValue } = require("firebase-admin/firestore");
const { getMessaging } = require("firebase-admin/messaging");

// -------- Setup --------
setGlobalOptions({
  region: "us-central1",
  memory: "256MiB",
  concurrency: 40, // safe & snappy
});

initializeApp();
const db = getFirestore();
const ts = FieldValue.serverTimestamp;

// Helpers
const inc = (field, by = 1) => ({ [field]: FieldValue.increment(by) });

async function getUserProfile(uid) {
  try {
    const snap = await db.doc(`users/${uid}`).get();
    return {
      name: snap.get("displayName") || "Someone",
      avatar: snap.get("photoURL") || null,
    };
  } catch {
    return { name: "Someone", avatar: null };
  }
}

async function pushToUser(uid, title, body, data = {}) {
  try {
    const user = await db.doc(`users/${uid}`).get();
    const tokens = user.get("fcmTokens") || [];
    if (!Array.isArray(tokens) || tokens.length === 0) return;

    await getMessaging().sendEachForMulticast({
      tokens,
      notification: { title, body },
      data,
      android: { priority: "high" },
      apns: { payload: { aps: { sound: "default" } } },
    });
  } catch {
    // ignore push errors (tokens can be stale)
  }
}

async function writeNotification(targetUid, notifId, payload) {
  // Writes under notifications/{uid}/items/{notifId}
  await db.collection("notifications").doc(targetUid)
    .collection("items").doc(notifId)
    .set(
      {
        userId: targetUid,
        isRead: false,
        createdAt: ts(),
        ...payload,
      },
      { merge: true }
    );
}

// =======================================================
// FOLLOW: create + delete follower docs
// Structure: follows/{targetUid}/followers/{meUid}
// Also mirror: follows/{meUid}/following/{targetUid} is written by client
// =======================================================

exports.onFollowerAdded = onDocumentCreated(
  "follows/{targetUid}/followers/{meUid}",
  async (event) => {
    const { targetUid, meUid } = event.params;
    if (!targetUid || !meUid || targetUid === meUid) return;

    const actor = await getUserProfile(meUid);
    const notifId = `follow:${meUid}`;

    // 1) Notification
    await writeNotification(targetUid, notifId, {
      type: "follow",
      actor: { id: meUid, name: actor.name, avatar: actor.avatar },
      entity: { type: "user", id: meUid },
      message: `${actor.name} started following you`,
      url: `/user/${meUid}`,
    });

    // 2) Counters (target: followersCount, me: followingCount)
    const batch = db.batch();
    batch.set(db.doc(`users/${targetUid}`), inc("followersCount", +1), { merge: true });
    batch.set(db.doc(`users/${meUid}`), inc("followingCount", +1), { merge: true });
    await batch.commit();

    // 3) Optional push
    await pushToUser(targetUid, "New follower", `${actor.name} started following you`, {
      type: "follow",
      actorId: meUid,
    });
  }
);

exports.onFollowerRemoved = onDocumentDeleted(
  "follows/{targetUid}/followers/{meUid}",
  async (event) => {
    const { targetUid, meUid } = event.params;
    if (!targetUid || !meUid || targetUid === meUid) return;

    const batch = db.batch();
    batch.set(db.doc(`users/${targetUid}`), inc("followersCount", -1), { merge: true });
    batch.set(db.doc(`users/${meUid}`), inc("followingCount", -1), { merge: true });
    await batch.commit();
  }
);

// =======================================================
// LIKE: posts/{postId}/likes/{actorId}
// Also updates posts.likeCount
// =======================================================

exports.onLikeCreate = onDocumentCreated(
  "posts/{postId}/likes/{actorId}",
  async (event) => {
    const { postId, actorId } = event.params;

    const postSnap = await db.doc(`posts/${postId}`).get();
    if (!postSnap.exists) return;

    const ownerId = postSnap.get("author.uid") || postSnap.get("uid");
    if (!ownerId || ownerId === actorId) return;

    // Notification
    const actor = await getUserProfile(actorId);
    const notifId = `like:${postId}:${actorId}`;

    await writeNotification(ownerId, notifId, {
      type: "like",
      actor: { id: actorId, name: actor.name, avatar: actor.avatar },
      entity: { type: "post", id: postId },
      message: `${actor.name} liked your post`,
      url: `/post/${postId}`,
    });

    // likeCount++
    await db.doc(`posts/${postId}`).set(inc("likeCount", +1), { merge: true });

    // Optional push
    await pushToUser(ownerId, "New like", `${actor.name} liked your post`, {
      type: "like",
      postId,
      actorId,
    });
  }
);

exports.onLikeDelete = onDocumentDeleted(
  "posts/{postId}/likes/{actorId}",
  async (event) => {
    const { postId } = event.params;
    await db.doc(`posts/${postId}`).set(inc("likeCount", -1), { merge: true });
  }
);

// =======================================================
// COMMENT: posts/{postId}/comments/{commentId}
// Also updates posts.commentCount
// =======================================================

exports.onCommentCreate = onDocumentCreated(
  "posts/{postId}/comments/{commentId}",
  async (event) => {
    const { postId, commentId } = event.params;
    const c = event.data?.data() || {};
    const actorId = c.actorId || c.userId || c.author?.uid;
    if (!actorId) return;

    const postSnap = await db.doc(`posts/${postId}`).get();
    if (!postSnap.exists) return;

    const ownerId = postSnap.get("author.uid") || postSnap.get("uid");
    if (!ownerId || ownerId === actorId) return;

    const actor = await getUserProfile(actorId);
    const notifId = `comment:${postId}:${commentId}`;

    await writeNotification(ownerId, notifId, {
      type: "comment",
      actor: { id: actorId, name: actor.name, avatar: actor.avatar },
      entity: { type: "post", id: postId },
      message: `${actor.name} commented on your post`,
      url: `/post/${postId}#comment-${commentId}`,
      preview: c.text ? String(c.text).slice(0, 140) : "",
    });

    await db.doc(`posts/${postId}`).set(inc("commentCount", +1), { merge: true });

    await pushToUser(ownerId, "New comment", `${actor.name} commented on your post`, {
      type: "comment",
      postId,
      actorId,
      commentId,
    });
  }
);

exports.onCommentDelete = onDocumentDeleted(
  "posts/{postId}/comments/{commentId}",
  async (event) => {
    const { postId } = event.params;
    await db.doc(`posts/${postId}`).set(inc("commentCount", -1), { merge: true });
  }
);

// =======================================================
// MESSAGES: chats/{chatId}/messages/{messageId}
// Notifies all participants except sender; optional push
// Expect chat doc: chats/{chatId} with { participants: [uid1, uid2, ...] }
// Message doc: { senderId, text, createdAt, ... }
// =======================================================

exports.onMessageCreate = onDocumentCreated(
  "chats/{chatId}/messages/{messageId}",
  async (event) => {
    const { chatId, messageId } = event.params;
    const m = event.data?.data() || {};
    const senderId = m.senderId || m.userId;
    if (!senderId) return;

    const chat = await db.doc(`chats/${chatId}`).get();
    if (!chat.exists) return;

    const participants = chat.get("participants") || [];
    if (!Array.isArray(participants) || participants.length === 0) return;

    const sender = await getUserProfile(senderId);
    const preview = m.text ? String(m.text).slice(0, 90) : "New message";

    // fan-out notifications to all recipients except sender
    const writes = [];
    for (const uid of participants) {
      if (uid === senderId) continue;
      const notifId = `message:${chatId}:${messageId}`;

      writes.push(
        writeNotification(uid, notifId, {
          type: "message",
          actor: { id: senderId, name: sender.name, avatar: sender.avatar },
          entity: { type: "chat", id: chatId },
          message: `${sender.name}: ${preview}`,
          url: `/chat/${chatId}`,
        })
      );

      // optional push
      writes.push(
        pushToUser(uid, `Message from ${sender.name}`, preview, {
          type: "message",
          chatId,
          senderId,
          messageId,
        })
      );
    }

    await Promise.allSettled(writes);
  }
);





const [isFollowing, setIsFollowing] = useState(false);

useEffect(() => {
  if (!user || !profile?.uid) return;
  // live follow status
  const unsub = onIsFollowing({ meUid: user.uid, targetUid: profile.uid }, setIsFollowing);
  return unsub;
}, [user, profile?.uid]);

const handleFollow = async () => {
  try {
    await followUser({
      meUid: user.uid,
      meProfile: { displayName: user.displayName, photoURL: user.photoURL },
      targetUid: profile.uid,
      targetProfile: { displayName: profile.displayName, photoURL: profile.photoURL },
    });
  } catch (e) {
    console.error(e);
    alert(e.message);
  }
};

const handleUnfollow = async () => {
  try {
    await unfollowUser({ meUid: user.uid, targetUid: profile.uid });
  } catch (e) {
    console.error(e);
    alert(e.message);
  }
};




import { db } from "../firebase";
import {
  doc,
  getDoc,
  setDoc,
  deleteDoc,
  writeBatch,
  serverTimestamp,
  collection,
  getCountFromServer,
  onSnapshot,
} from "firebase/firestore";

/** FOLLOW (writes only to follows/*; Cloud Function creates the notification) */
export async function followUser({ meUid, meProfile, targetUid, targetProfile }) {
  if (!meUid || !targetUid || meUid === targetUid) return;

  const batch = writeBatch(db);

  // A) target's followers: follows/<targetUid>/followers/<meUid>
  batch.set(
    doc(db, "follows", targetUid, "followers", meUid),
    {
      uid: meUid,
      displayName: meProfile?.displayName || "",
      photoURL: meProfile?.photoURL || "",
      createdAt: serverTimestamp(),
    },
    { merge: true }
  );

  // B) my following: follows/<meUid>/following/<targetUid>
  batch.set(
    doc(db, "follows", meUid, "following", targetUid),
    {
      uid: targetUid,
      displayName: targetProfile?.displayName || "",
      photoURL: targetProfile?.photoURL || "",
      createdAt: serverTimestamp(),
    },
    { merge: true }
  );

  await batch.commit();

  // ⛔️ Do NOT write notifications here. Cloud Function onFollowCreate will add:
  // notifications/<targetUid>/items/follow:<meUid>
}

/** UNFOLLOW */
export async function unfollowUser({ meUid, targetUid }) {
  if (!meUid || !targetUid || meUid === targetUid) return;

  const batch = writeBatch(db);
  batch.delete(doc(db, "follows", targetUid, "followers", meUid));
  batch.delete(doc(db, "follows", meUid, "following", targetUid));
  await batch.commit();
}

/** One-time check: am I following target? */
export async function isFollowing({ meUid, targetUid }) {
  if (!meUid || !targetUid) return false;
  const snap = await getDoc(doc(db, "follows", meUid, "following", targetUid));
  return snap.exists();
}

/** Live subscription to following status (optional but nice) */
export function onIsFollowing({ meUid, targetUid }, callback) {
  if (!meUid || !targetUid) return () => {};
  const ref = doc(db, "follows", meUid, "following", targetUid);
  return onSnapshot(ref, (snap) => callback(snap.exists()));
}

/** Quick counts */
export async function getFollowCounts(uid) {
  const followingCount = (
    await getCountFromServer(collection(db, "follows", uid, "following"))
  ).data().count;

  const followersCount = (
    await getCountFromServer(collection(db, "follows", uid, "followers"))
  ).data().count;

  return { followingCount, followersCount };
}





import { db } from "../firebase";
import {
  doc,
  getDoc,
  setDoc,
  deleteDoc,
  serverTimestamp,
  runTransaction,
  collection,
  getCountFromServer
} from "firebase/firestore";

export async function followUser({ meUid, meProfile, targetUid, targetProfile }) {
  if (!meUid || !targetUid || meUid === targetUid) return;

  await runTransaction(db, async (tx) => {
    const myFollowingRef = doc(db, "follows", meUid, "following", targetUid);
    const theirFollowersRef = doc(db, "follows", targetUid, "followers", meUid);

    const myFollowingSnap = await tx.get(myFollowingRef);
    if (!myFollowingSnap.exists()) {
      tx.set(myFollowingRef, {
        uid: targetUid,
        displayName: targetProfile?.displayName || "",
        photoURL: targetProfile?.photoURL || "",
        createdAt: serverTimestamp(),
      });
      tx.set(theirFollowersRef, {
        uid: meUid,
        displayName: meProfile?.displayName || "",
        photoURL: meProfile?.photoURL || "",
        createdAt: serverTimestamp(),
      });
    }
  });

  // Add a notification to the target
  await setDoc(doc(collection(db, "notifications", targetUid, "items")), {
    type: "follow",
    fromUid: meUid,
    fromName: meProfile?.displayName || "",
    fromPhoto: meProfile?.photoURL || "",
    createdAt: serverTimestamp(),
    read: false,
  });
}

/** Unfollow */
export async function unfollowUser({ meUid, targetUid }) {
  if (!meUid || !targetUid || meUid === targetUid) return;
  await runTransaction(db, async (tx) => {
    tx.delete(doc(db, "follows", meUid, "following", targetUid));
    tx.delete(doc(db, "follows", targetUid, "followers", meUid));
  });
}

/** Am I following this user? */
export async function isFollowing({ meUid, targetUid }) {
  if (!meUid || !targetUid) return false;
  const snap = await getDoc(doc(db, "follows", meUid, "following", targetUid));
  return snap.exists();
}

/** Quick counts */
export async function getFollowCounts(uid) {
  const followingCount = (await getCountFromServer(collection(db, "follows", uid, "following"))).data().count;
  const followersCount = (await getCountFromServer(collection(db, "follows", uid, "followers"))).data().count;
  return { followingCount, followersCount };
}





import { doc, setDoc, deleteDoc, writeBatch, serverTimestamp } from "firebase/firestore";
import { getAuth } from "firebase/auth";
import { db } from "./firebase"; // adjust the path if needed

// Follow someone
export async function followUser(targetUid) {
  const me = getAuth().currentUser?.uid;
  if (!me) throw new Error("User not signed in");

  const batch = writeBatch(db);

  // Add me to target's followers
  batch.set(doc(db, "follows", targetUid, "followers", me), {
    createdAt: serverTimestamp(),
  });

  // Add target to my following
  batch.set(doc(db, "follows", me, "following", targetUid), {
    createdAt: serverTimestamp(),
  });

  await batch.commit();
}

// Unfollow someone
export async function unfollowUser(targetUid) {
  const me = getAuth().currentUser?.uid;
  if (!me) throw new Error("User not signed in");

  const batch = writeBatch(db);
  batch.delete(doc(db, "follows", targetUid, "followers", me));
  batch.delete(doc(db, "follows", me, "following", targetUid));
  await batch.commit();
}


const [isFollowing, setIsFollowing] = useState(false);
const auth = getAuth();
const me = auth.currentUser?.uid;

// Temporary simple follow button
const handleFollow = async () => {
  if (!profile?.uid) return;
  try {
    await followUser(profile.uid);
    setIsFollowing(true);
    alert("Followed!");
  } catch (err) {
    console.error("Follow error:", err);
    alert(err.message);
  }
};

const handleUnfollow = async () => {
  if (!profile?.uid) return;
  try {
    await unfollowUser(profile.uid);
    setIsFollowing(false);
    alert("Unfollowed!");
  } catch (err) {
    console.error("Unfollow error:", err);
    alert(err.message);
  }
};


rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --- USERS ---------------------------------------------------------
    match /users/{uid} {
      allow read: if true;
      allow create, update, delete: if request.auth != null && request.auth.uid == uid;
    }

    // --- POSTS ---------------------------------------------------------
    match /posts/{postId} {
      allow read: if true;
      allow create: if request.auth != null && request.resource.data.uid == request.auth.uid;
      allow delete, update: if request.auth != null && request.auth.uid == resource.data.uid;

      // LIKES
      match /likes/{actorId} {
        allow read: if true;
        allow write: if request.auth != null && request.auth.uid == actorId;
      }

      // COMMENTS
      match /comments/{commentId} {
        allow read: if true;
        allow create: if request.auth != null;
        allow update, delete: if request.auth != null && request.auth.uid == resource.data.author.uid;
      }
    }

    // --- FOLLOWS -------------------------------------------------------
    // follows/{uid}/followers/{sourceUid}  &  follows/{uid}/following/{targetUid}
    match /follows/{uid} {
      allow read: if true;

      match /followers/{sourceUid} {
        allow read: if true;
        // the follower writes under their own UID
        allow write: if request.auth != null && request.auth.uid == sourceUid;
      }

      match /following/{targetUid} {
        allow read: if true;
        // the current user writes to their own "following"
        allow write: if request.auth != null && request.auth.uid == uid;
      }
    }

    // --- NOTIFICATIONS -------------------------------------------------
    // notifications/{uid}/items/{notifId}
    match /notifications/{uid} {
      // owner can get/list the container
      allow get, list: if request.auth != null && request.auth.uid == uid;

      match /items/{notifId} {
        // owner can read their items
        allow get, list: if request.auth != null && request.auth.uid == uid;

        // owner can only toggle 'isRead' from the client
        allow update: if request.auth != null
                      && request.auth.uid == uid
                      && request.resource.data.diff(resource.data).changedKeys().hasOnly(['isRead']);

        // creation/deletion comes from Cloud Functions (Admin SDK bypasses rules)
        allow create, delete: if false;
      }
    }

    // (your other collections … chats/messages/reports … if you have them)
  }
}



PROJECT_ID=petsnaps-882dd
PROJECT_NUMBER=57585989255

# Grant Eventarc Service Agent role
gcloud projects add-iam-policy-binding $PROJECT_ID \
  --member="serviceAccount:service-$PROJECT_NUMBER@gcp-sa-eventarc.iam.gserviceaccount.com" \
  --role="roles/eventarc.serviceAgent"

# Also grant Pub/Sub Publisher (often needed for Firestore triggers)
gcloud projects add-iam-policy-binding $PROJECT_ID \
  --member="serviceAccount:service-$PROJECT_NUMBER@gcp-sa-eventarc.iam.gserviceaccount.com" \
  --role="roles/pubsub.publisher"




PS C:\Users\thuht\Petsnaps\functions> firebase deploy --only functions

=== Deploying to 'petsnaps-882dd'...

i  deploying functions
i  functions: preparing codebase default for deployment
i  functions: ensuring required API cloudfunctions.googleapis.com is enabled...
i  functions: ensuring required API cloudbuild.googleapis.com is enabled...
i  artifactregistry: ensuring required API artifactregistry.googleapis.com is enabled...
!  functions: package.json indicates an outdated version of firebase-functions. Please upgrade using npm install --save firebase-functions@latest in your functions directory.
!  functions: Please note that there will be breaking changes when you upgrade.
i  functions: Loading and analyzing source code for codebase default to determine what to deploy
Serving at port 8914

i  extensions: ensuring required API firebaseextensions.googleapis.com is enabled...
!  extensions: missing required API firebaseextensions.googleapis.com. Enabling now...
i  functions: preparing functions directory for uploading...
i  functions: packaged C:\Users\thuht\Petsnaps\functions (77.91 KB) for uploading
i  functions: ensuring required API run.googleapis.com is enabled...
i  functions: ensuring required API eventarc.googleapis.com is enabled...
i  functions: ensuring required API pubsub.googleapis.com is enabled...
i  functions: ensuring required API storage.googleapis.com is enabled...
!  functions: missing required API run.googleapis.com. Enabling now...
!  functions: missing required API eventarc.googleapis.com. Enabling now...
+  functions: required API pubsub.googleapis.com is enabled
+  functions: required API storage.googleapis.com is enabled
i  functions: generating the service identity for pubsub.googleapis.com...
i  functions: generating the service identity for eventarc.googleapis.com...
+  functions: functions source uploaded successfully
i  functions: creating Node.js 20 (2nd Gen) function onFollowCreate(us-central1)...
i  functions: creating Node.js 20 (2nd Gen) function onLikeCreate(us-central1)...
i  functions: creating Node.js 20 (2nd Gen) function onCommentCreate(us-central1)...
!  functions: Request to https://cloudfunctions.googleapis.com/v2/projects/petsnaps-882dd/locations/us-central1/functions?functionId=onFollowCreate had HTTP Error: 400, Validation failed for trigger projects/petsnaps-882dd/locations/nam5/triggers/onfollowcreate-334365: Invalid resource state for "": Permission denied while using the Eventarc Service Agent. If you recently started to use Eventarc, it may take a few minutes before all necessary permissions are propagated to the Service Agent. Otherwise, verify that it has Eventarc Service Agent role.
!  functions: Since this is your first time using 2nd gen functions, we need a little bit longer to finish setting everything up. Retry the deployment in a few minutes.
!  functions:  failed to create function projects/petsnaps-882dd/locations/us-central1/functions/onFollowCreate
Failed to create function projects/petsnaps-882dd/locations/us-central1/functions/onFollowCreate
!  functions: Request to https://cloudfunctions.googleapis.com/v2/projects/petsnaps-882dd/locations/us-central1/functions?functionId=onLikeCreate had HTTP Error: 400, Validation failed for trigger projects/petsnaps-882dd/locations/nam5/triggers/onlikecreate-969654: Invalid resource state for "": Permission denied while using the Eventarc Service Agent. If you recently started to use Eventarc, it may take a few minutes before all necessary permissions are propagated to the Service Agent. Otherwise, verify that it has Eventarc Service Agent role.
!  functions: Since this is your first time using 2nd gen functions, we need a little bit longer to finish setting everything up. Retry the deployment in a few minutes.
!  functions:  failed to create function projects/petsnaps-882dd/locations/us-central1/functions/onLikeCreate
Failed to create function projects/petsnaps-882dd/locations/us-central1/functions/onLikeCreate
!  functions: Request to https://cloudfunctions.googleapis.com/v2/projects/petsnaps-882dd/locations/us-central1/functions?functionId=onCommentCreate had HTTP Error: 400, Validation failed for trigger projects/petsnaps-882dd/locations/nam5/triggers/oncommentcreate-054626: Invalid resource state for "": Permission denied while using the Eventarc Service Agent. If you recently started to use Eventarc, it may take a few minutes before all necessary permissions are propagated to the Service Agent. Otherwise, verify that it has Eventarc Service Agent role.
!  functions: Since this is your first time using 2nd gen functions, we need a little bit longer to finish setting everything up. Retry the deployment in a few minutes.
!  functions:  failed to create function projects/petsnaps-882dd/locations/us-central1/functions/onCommentCreate
Failed to create function projects/petsnaps-882dd/locations/us-central1/functions/onCommentCreate

Functions deploy had errors with the following functions:
        onCommentCreate(us-central1)
        onFollowCreate(us-central1)
        onLikeCreate(us-central1)
Error: There was an error deploying functions:
- Error Failed to create function onFollowCreate in region us-central1
- Error Failed to create function onLikeCreate in region us-central1
- Error Failed to create function onCommentCreate in region us-central1
PS C:\Users\thuht\Petsnaps\functions>



// functions/index.js (v2 syntax)

const { onDocumentCreated } = require("firebase-functions/v2/firestore");
const { initializeApp } = require("firebase-admin/app");
const { getFirestore, FieldValue } = require("firebase-admin/firestore");

initializeApp();
const db = getFirestore();
const ts = FieldValue.serverTimestamp;

// helper: read actor name/avatar (safe)
async function getActor(actorId) {
  try {
    const snap = await db.doc(`users/${actorId}`).get();
    return {
      name: snap.get("displayName") || "Someone",
      avatar: snap.get("photoURL") || null,
    };
  } catch {
    return { name: "Someone", avatar: null };
  }
}

/**
 * FOLLOW -> notify target user
 * Path: follows/{targetId}/followers/{actorId}
 */
exports.onFollowCreate = onDocumentCreated(
  "follows/{targetId}/followers/{actorId}",
  async (event) => {
    const { targetId, actorId } = event.params;
    if (targetId === actorId) return;

    const actor = await getActor(actorId);
    const notifId = `follow:${actorId}`; // one per follower

    await db.collection("notifications").doc(targetId)
      .collection("items").doc(notifId)
      .set({
        userId: targetId,
        actor: { id: actorId, name: actor.name, avatar: actor.avatar },
        type: "follow",
        entity: { type: "user", id: actorId },
        message: `${actor.name} started following you`,
        url: `/user/${actorId}`,
        isRead: false,
        createdAt: ts(),
      }, { merge: true });
  }
);

/**
 * LIKE -> notify post owner
 * Path: posts/{postId}/likes/{actorId}
 */
exports.onLikeCreate = onDocumentCreated(
  "posts/{postId}/likes/{actorId}",
  async (event) => {
    const { postId, actorId } = event.params;

    const postSnap = await db.doc(`posts/${postId}`).get();
    if (!postSnap.exists) return;

    const ownerId = postSnap.get("author.uid") || postSnap.get("uid");
    if (!ownerId || ownerId === actorId) return;

    const actor = await getActor(actorId);
    const notifId = `like:${postId}:${actorId}`; // one like per actor per post

    await db.collection("notifications").doc(ownerId)
      .collection("items").doc(notifId)
      .set({
        userId: ownerId,
        actor: { id: actorId, name: actor.name, avatar: actor.avatar },
        type: "like",
        entity: { type: "post", id: postId },
        message: `${actor.name} liked your post`,
        url: `/post/${postId}`,
        isRead: false,
        createdAt: ts(),
      }, { merge: true });
  }
);

/**
 * COMMENT -> notify post owner
 * Path: posts/{postId}/comments/{commentId}
 */
exports.onCommentCreate = onDocumentCreated(
  "posts/{postId}/comments/{commentId}",
  async (event) => {
    const { postId, commentId } = event.params;
    const c = event.data?.data() || {};

    const actorId = c.actorId || c.userId || c.author?.uid;
    if (!actorId) return;

    const postSnap = await db.doc(`posts/${postId}`).get();
    if (!postSnap.exists) return;

    const ownerId = postSnap.get("author.uid") || postSnap.get("uid");
    if (!ownerId || ownerId === actorId) return;

    const actor = await getActor(actorId);
    const notifId = `comment:${postId}:${commentId}`;

    await db.collection("notifications").doc(ownerId)
      .collection("items").doc(notifId)
      .set({
        userId: ownerId,
        actor: { id: actorId, name: actor.name, avatar: actor.avatar },
        type: "comment",
        entity: { type: "post", id: postId },
        message: `${actor.name} commented on your post`,
        url: `/post/${postId}#comment-${commentId}`,
        isRead: false,
        createdAt: ts(),
      }, { merge: true });
  }
);



const functions = require("firebase-functions");
const admin = require("firebase-admin");
admin.initializeApp();
const db = admin.firestore();
const ts = admin.firestore.FieldValue.serverTimestamp;

// helper to safely read user profile (name + avatar)
async function getActor(actorId) {
  try {
    const snap = await db.doc(`users/${actorId}`).get();
    return {
      name: snap.get("displayName") || "Someone",
      avatar: snap.get("photoURL") || null,
    };
  } catch {
    return { name: "Someone", avatar: null };
  }
}

// ========== FOLLOW ==========
exports.onFollowCreate = functions.firestore
  .document("follows/{targetId}/followers/{actorId}")
  .onCreate(async (snap, ctx) => {
    const { targetId, actorId } = ctx.params;
    if (targetId === actorId) return;

    const actor = await getActor(actorId);
    const notifId = `follow:${actorId}`; // one per follower

    await db.collection("notifications").doc(targetId)
      .collection("items").doc(notifId)
      .set({
        userId: targetId,
        actor: { id: actorId, name: actor.name, avatar: actor.avatar },
        type: "follow",
        entity: { type: "user", id: actorId },
        message: `${actor.name} started following you`,
        url: `/user/${actorId}`,
        isRead: false,
        createdAt: ts(),
      }, { merge: true });
  });

// ========== LIKE ==========
exports.onLikeCreate = functions.firestore
  .document("posts/{postId}/likes/{actorId}")
  .onCreate(async (snap, ctx) => {
    const { postId, actorId } = ctx.params;

    const postSnap = await db.doc(`posts/${postId}`).get();
    if (!postSnap.exists) return;

    const ownerId = postSnap.get("author.uid") || postSnap.get("uid");
    if (!ownerId || ownerId === actorId) return;

    const actor = await getActor(actorId);
    const notifId = `like:${postId}:${actorId}`;

    await db.collection("notifications").doc(ownerId)
      .collection("items").doc(notifId)
      .set({
        userId: ownerId,
        actor: { id: actorId, name: actor.name, avatar: actor.avatar },
        type: "like",
        entity: { type: "post", id: postId },
        message: `${actor.name} liked your post`,
        url: `/post/${postId}`,
        isRead: false,
        createdAt: ts(),
      }, { merge: true });
  });

// ========== COMMENT ==========
exports.onCommentCreate = functions.firestore
  .document("posts/{postId}/comments/{commentId}")
  .onCreate(async (snap, ctx) => {
    const { postId, commentId } = ctx.params;
    const c = snap.data() || {};
    const actorId = c.actorId || c.userId || c.author?.uid;
    if (!actorId) return;

    const postSnap = await db.doc(`posts/${postId}`).get();
    if (!postSnap.exists) return;

    const ownerId = postSnap.get("author.uid") || postSnap.get("uid");
    if (!ownerId || ownerId === actorId) return;

    const actor = await getActor(actorId);
    const notifId = `comment:${postId}:${commentId}`;

    await db.collection("notifications").doc(ownerId)
      .collection("items").doc(notifId)
      .set({
        userId: ownerId,
        actor: { id: actorId, name: actor.name, avatar: actor.avatar },
        type: "comment",
        entity: { type: "post", id: postId },
        message: `${actor.name} commented on your post`,
        url: `/post/${postId}#comment-${commentId}`,
        isRead: false,
        createdAt: ts(),
      }, { merge: true });
  });







rules_version = '2';
service cloud.firestore {
  match /databases/{db}/documents {

    // --- USERS ---------------------------------------------------------
    match /users/{uid} {
      allow read: if true; // anyone can view profiles
      allow create, update, delete: if request.auth != null && request.auth.uid == uid;
    }

    // --- POSTS ---------------------------------------------------------
    match /posts/{postId} {
      allow read: if true; // public feed
      allow create: if request.auth != null && request.resource.data.uid == request.auth.uid;
      allow delete: if request.auth != null && resource.data.uid == request.auth.uid;
      allow update: if request.auth != null && request.auth.uid == resource.data.uid;
      
      // --- COMMENTS (subcollection) -----------------------------------
      match /comments/{commentId} {
        allow read: if true;
        allow create: if request.auth != null;
        allow delete: if request.auth != null && request.auth.uid == resource.data.author.uid;
        allow update: if request.auth != null && request.auth.uid == resource.data.author.uid;
      }

      // --- LIKES (subcollection) --------------------------------------
      match /likes/{actorId} {
        allow read: if true;
        allow write: if request.auth != null && request.auth.uid == actorId;
      }
    }

    // --- CHATS --------------------------------------------------------- 
    match /chats/{chatId} {
      allow read, write: if request.auth != null;

      match /messages/{messageId} {
        allow read, write: if request.auth != null;
      }
    }

    // --- FOLLOWS -------------------------------------------------------
    // Structure: follows/{uid}/followers/{sourceUid}  &  follows/{uid}/following/{targetUid}
    match /follows/{uid} {
      allow read: if true;  // anyone can view followers/following lists

      match /following/{targetUid} {
        allow read: if true;
        allow write: if request.auth != null && request.auth.uid == uid;
      }

      match /followers/{sourceUid} {
        allow read: if true;
        allow write: if request.auth != null && request.auth.uid == sourceUid;
      }
    }

    // --- NOTIFICATIONS -------------------------------------------------
    // Structure: notifications/{uid}/items/{notifId}
    match /notifications/{uid} {

      // user can list their own notification container doc
      allow get, list: if request.auth != null && request.auth.uid == uid;

      match /items/{notifId} {
        // owner can read their notifications
        allow get, list: if request.auth != null && request.auth.uid == uid;

        // owner can mark them read (only change 'isRead')
        allow update: if request.auth != null
                      && request.auth.uid == uid
                      && request.resource.data.diff(resource.data)
                          .changedKeys()
                          .hasOnly(['isRead']);

        // notifications should be created by Cloud Functions (admin SDK bypasses rules)
        // block normal users from manually creating or deleting notifications
        allow create, delete: if false;
      }
    }

    // --- MESSAGES ------------------------------------------------------
    match /messages/{messageId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      allow update, delete: if request.auth != null &&
        request.auth.uid == resource.data.senderId;
    }

    // --- REPORTS -------------------------------------------------------
    match /reports/{reportId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null;
      allow update, delete: if request.auth != null &&
        request.auth.uid == resource.data.reporterId;
    }

  } // end documents
} // end service



// functions/src/index.ts
import * as functions from 'firebase-functions';
import * as admin from 'firebase-admin';
admin.initializeApp();
const db = admin.firestore();
const ts = admin.firestore.FieldValue.serverTimestamp;


.........

export const onFollowCreate = functions.firestore
  .document('follows/{targetId}/followers/{actorId}')
  .onCreate(async (snap, ctx) => {
    const { targetId, actorId } = ctx.params as { targetId: string; actorId: string };
    if (targetId === actorId) return;

    const actor = await db.doc(`users/${actorId}`).get().catch(() => null);
    const actorName = actor?.get('displayName') ?? 'Someone';
    const actorAvatar = actor?.get('photoURL') ?? null;

    const notifId = `follow:${actorId}`;              // one per follower
    await db.collection('notifications').doc(targetId)
      .collection('items').doc(notifId)
      .set({
        userId: targetId,
        actor: { id: actorId, name: actorName, avatar: actorAvatar },
        type: 'follow',
        entity: { type: 'user', id: actorId },
        message: `${actorName} started following you`,
        url: `/user/${actorId}`,
        isRead: false,
        createdAt: ts(),
      }, { merge: true });
  });




,.........




export const onLikeCreate = functions.firestore
  .document('posts/{postId}/likes/{actorId}')
  .onCreate(async (snap, ctx) => {
    const { postId, actorId } = ctx.params as { postId: string; actorId: string };

    const [postSnap, actorSnap] = await Promise.all([
      db.doc(`posts/${postId}`).get(),
      db.doc(`users/${actorId}`).get().catch(() => null),
    ]);
    if (!postSnap.exists) return;

    const postOwnerId = postSnap.get('author.uid') || postSnap.get('ownerId'); // pick your field
    if (!postOwnerId || postOwnerId === actorId) return;

    const actorName = actorSnap?.get('displayName') ?? 'Someone';
    const actorAvatar = actorSnap?.get('photoURL') ?? null;

    const notifId = `like:${postId}:${actorId}`;     // one like per user per post
    await db.collection('notifications').doc(postOwnerId)
      .collection('items').doc(notifId)
      .set({
        userId: postOwnerId,
        actor: { id: actorId, name: actorName, avatar: actorAvatar },
        type: 'like',
        entity: { type: 'post', id: postId },
        message: `${actorName} liked your post`,
        url: `/post/${postId}`,
        isRead: false,
        createdAt: ts(),
      }, { merge: true });
  });



.......


export const onCommentCreate = functions.firestore
  .document('posts/{postId}/comments/{commentId}')
  .onCreate(async (snap, ctx) => {
    const { postId } = ctx.params as { postId: string; commentId: string };
    const c = snap.data() as any;                    // { actorId, text, ... }
    const actorId = c.actorId || c.userId;

    const [postSnap, actorSnap] = await Promise.all([
      db.doc(`posts/${postId}`).get(),
      db.doc(`users/${actorId}`).get().catch(() => null),
    ]);
    if (!postSnap.exists || !actorId) return;

    const postOwnerId = postSnap.get('author.uid') || postSnap.get('ownerId');
    if (!postOwnerId || postOwnerId === actorId) return;

    const actorName = actorSnap?.get('displayName') ?? 'Someone';
    const actorAvatar = actorSnap?.get('photoURL') ?? null;

    const notifId = `comment:${postId}:${snap.id}`;  // every comment unique
    await db.collection('notifications').doc(postOwnerId)
      .collection('items').doc(notifId)
      .set({
        userId: postOwnerId,
        actor: { id: actorId, name: actorName, avatar: actorAvatar },
        type: 'comment',
        entity: { type: 'post', id: postId },
        message: `${actorName} commented on your post`,
        url: `/post/${postId}#comment-${snap.id}`,
        isRead: false,
        createdAt: ts(),
      }, { merge: true });
  });



......



import { collection, query, orderBy, where, limit, onSnapshot } from 'firebase/firestore';
import { db } from '@/firebase';
import { getAuth } from 'firebase/auth';

export function listenNotifications(onChange: (items:any[]) => void) {
  const uid = getAuth().currentUser?.uid;
  if (!uid) return () => {};

  const q = query(
    collection(db, `notifications/${uid}/items`),
    orderBy('createdAt', 'desc'),
    limit(20)
  );

  return onSnapshot(q, (snap) => {
    const items = snap.docs.map(d => ({ id: d.id, ...d.data() }));
    onChange(items);
  });
}



........


export function listenUnreadCount(onChange: (n:number) => void) {
  const uid = getAuth().currentUser?.uid;
  if (!uid) return () => {};

  const q = query(
    collection(db, `notifications/${uid}/items`),
    where('isRead', '==', false)
  );
  return onSnapshot(q, (snap) => onChange(snap.size));
}

.......



import { doc, updateDoc, writeBatch, getDocs, query, collection, where } from 'firebase/firestore';

export async function markOneRead(uid: string, notifId: string) {
  await updateDoc(doc(db, `notifications/${uid}/items/${notifId}`), { isRead: true });
}

export async function markAllRead(uid: string) {
  const q = query(collection(db, `notifications/${uid}/items`), where('isRead','==', false));
  const snap = await getDocs(q);
  const batch = writeBatch(db);
  snap.forEach(d => batch.update(d.ref, { isRead: true }));
  await batch.commit();
}



.....



function go(url?: string) {
  if (!url) return;
  try { new URL(url, window.location.origin); window.location.assign(url); }
  catch { /* ignore invalid URL */ }
}



......







rules_version = '2';
service cloud.firestore {
  match /databases/{db}/documents {

    // ----- USERS (leave yours as-is if already working) -----
    match /users/{uid} {
      allow read: if true;
      allow create, update, delete: if request.auth != null && request.auth.uid == uid;

      match /posts/{postId} {
        allow read, write: if request.auth != null && request.auth.uid == uid;
      }
    }

    // ----- CHATS + MESSAGES  (this is the important fix) -----
    match /chats/{chatId} {

      // READ existing chat: check membership on the existing resource
      allow read: if request.auth != null
                  && (resource.data.members is list)
                  && (request.auth.uid in resource.data.members);

      // CREATE new chat: check membership on the *incoming* data
      allow create: if request.auth != null
                    && (request.resource.data.members is list)
                    && (request.auth.uid in request.resource.data.members);

      // UPDATE/DELETE chat: user must be a member of the existing chat
      allow update, delete: if request.auth != null
                            && (resource.data.members is list)
                            && (request.auth.uid in resource.data.members);

      // Messages subcollection: only chat members can read/write
      match /messages/{msgId} {
        allow read, create: if request.auth != null
                             && (request.auth.uid in
                                get(/databases/$(db)/documents/chats/$(chatId)).data.members);

        // Optional: allow message updates only by the sender
        allow update, delete: if request.auth != null
                               && (request.auth.uid in
                                  get(/databases/$(db)/documents/chats/$(chatId)).data.members);
      }
    }

    // ----- POSTS (leave your working rules or keep this baseline) -----
    match /posts/{postId} {
      allow read: if true;
      allow create: if request.auth != null
                    && request.resource.data.uid == request.auth.uid;
      allow update, delete: if request.auth != null
                            && resource.data.uid == request.auth.uid;
    }
  }
}

......


// src/services/socialApi.js
import { db } from "../firebase";
import {
  doc,
  getDoc,
  setDoc,
  deleteDoc,
  serverTimestamp,
  runTransaction,
  collection,
  getCountFromServer
} from "firebase/firestore";

/** Follow targetUid from meUid and create a follow notification */
export async function followUser({ meUid, meProfile, targetUid, targetProfile }) {
  if (!meUid || !targetUid || meUid === targetUid) return;

  await runTransaction(db, async (tx) => {
    const myFollowingRef = doc(db, "follows", meUid, "following", targetUid);
    const theirFollowersRef = doc(db, "follows", targetUid, "followers", meUid);

    const myFollowingSnap = await tx.get(myFollowingRef);
    if (!myFollowingSnap.exists()) {
      tx.set(myFollowingRef, {
        uid: targetUid,
        displayName: targetProfile?.displayName || "",
        photoURL: targetProfile?.photoURL || "",
        createdAt: serverTimestamp(),
      });
      tx.set(theirFollowersRef, {
        uid: meUid,
        displayName: meProfile?.displayName || "",
        photoURL: meProfile?.photoURL || "",
        createdAt: serverTimestamp(),
      });
    }
  });

  // Add a notification to the target
  await setDoc(doc(collection(db, "notifications", targetUid, "items")), {
    type: "follow",
    fromUid: meUid,
    fromName: meProfile?.displayName || "",
    fromPhoto: meProfile?.photoURL || "",
    createdAt: serverTimestamp(),
    read: false,
  });
}

/** Unfollow */
export async function unfollowUser({ meUid, targetUid }) {
  if (!meUid || !targetUid || meUid === targetUid) return;
  await runTransaction(db, async (tx) => {
    tx.delete(doc(db, "follows", meUid, "following", targetUid));
    tx.delete(doc(db, "follows", targetUid, "followers", meUid));
  });
}

/** Am I following this user? */
export async function isFollowing({ meUid, targetUid }) {
  if (!meUid || !targetUid) return false;
  const snap = await getDoc(doc(db, "follows", meUid, "following", targetUid));
  return snap.exists();
}

/** Quick counts */
export async function getFollowCounts(uid) {
  const followingCount = (await getCountFromServer(collection(db, "follows", uid, "following"))).data().count;
  const followersCount = (await getCountFromServer(collection(db, "follows", uid, "followers"))).data().count;
  return { followingCount, followersCount };
}

.......




// src/components/FollowButton.jsx
import React, { useEffect, useState } from "react";
import { followUser, unfollowUser, isFollowing } from "../services/socialApi";

export default function FollowButton({ me, target, className = "" }) {
  const [loading, setLoading] = useState(false);
  const [following, setFollowing] = useState(false);

  useEffect(() => {
    let mounted = true;
    (async () => {
      if (!me?.uid || !target?.uid || me.uid === target.uid) return;
      const ok = await isFollowing({ meUid: me.uid, targetUid: target.uid });
      if (mounted) setFollowing(ok);
    })();
    return () => (mounted = false);
  }, [me?.uid, target?.uid]);

  if (!me?.uid || !target?.uid || me.uid === target.uid) return null;

  async function toggle() {
    setLoading(true);
    try {
      if (following) {
        await unfollowUser({ meUid: me.uid, targetUid: target.uid });
        setFollowing(false);
      } else {
        await followUser({
          meUid: me.uid,
          meProfile: { displayName: me.displayName, photoURL: me.photoURL },
          targetUid: target.uid,
          targetProfile: { displayName: target.displayName, photoURL: target.photoURL },
        });
        setFollowing(true);
      }
    } finally {
      setLoading(false);
    }
  }

  return (
    <button
      disabled={loading}
      onClick={toggle}
      className={
        (following
          ? "bg-[#FFE7CC] border border-[#E2B887]/60 text-[#8B6F47]"
          : "bg-[#E2B887] text-white") +
        " px-3 py-1.5 rounded-full text-sm " + className
      }
    >
      {loading ? "…" : following ? "Following" : "Follow"}
    </button>
  );
}



.........


// src/pages/NotificationsPage.js
import React, { useEffect, useState } from "react";
import { useAuth } from "../context/AuthContext";
import { db } from "../firebase";
import { collection, onSnapshot, orderBy, query, updateDoc } from "firebase/firestore";

export default function NotificationsPage() {
  const { user } = useAuth();
  const [items, setItems] = useState([]);

  useEffect(() => {
    if (!user) return;
    const q = query(
      collection(db, "notifications", user.uid, "items"),
      orderBy("createdAt", "desc")
    );
    const unsub = onSnapshot(q, (snap) => {
      setItems(snap.docs.map((d) => ({ id: d.id, ...d.data() })));
    });
    return unsub;
  }, [user]);

  async function markRead(id) {
    await updateDoc(
      collection(db, "notifications", user.uid, "items").doc
        ? collection(db, "notifications", user.uid, "items").doc(id)
        : null,
      { read: true }
    ).catch(() => {});
  }

  return (
    <div className="min-h-[calc(100vh-80px)] bg-[#FFE7CC]">
      <div className="max-w-2xl mx-auto p-6">
        <h2 className="text-2xl font-bold text-[#8B6F47] mb-4">Notifications</h2>
        <div className="space-y-3">
          {items.length === 0 && (
            <div className="text-[#8B6F47]/70">No notifications yet.</div>
          )}
          {items.map((n) => (
            <div
              key={n.id}
              className={
                "bg-white/90 rounded-xl p-3 border " +
                (n.read ? "border-transparent" : "border-[#E2B887]/60")
              }
              onClick={() => markRead(n.id)}
            >
              {n.type === "follow" ? (
                <div className="flex items-center gap-3">
                  <img
                    src={n.fromPhoto || "https://i.pravatar.cc/40?img=11"}
                    alt=""
                    className="w-8 h-8 rounded-full object-cover"
                  />
                  <div className="text-[#8B6F47]">
                    <b>{n.fromName || "Someone"}</b> started following you.
                  </div>
                </div>
              ) : (
                <div className="text-[#8B6F47]">Notification</div>
              )}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}


........


// src/pages/SearchPage.js
import React, { useEffect, useMemo, useState } from "react";
import { db } from "../firebase";
import { collection, getDocs, limit, orderBy, query } from "firebase/firestore";
import { useNavigate } from "react-router-dom";

export default function SearchPage() {
  const [qtext, setQtext] = useState("");
  const [users, setUsers] = useState([]);
  const nav = useNavigate();

  useEffect(() => {
    (async () => {
      // simple: load first ~100 users; client-filter
      const snap = await getDocs(query(collection(db, "users"), orderBy("displayName"), limit(100)));
      setUsers(snap.docs.map((d) => ({ uid: d.id, ...d.data() })));
    })();
  }, []);

  const filtered = useMemo(() => {
    const t = qtext.trim().toLowerCase();
    if (!t) return users;
    return users.filter((u) =>
      (u.displayName || "").toLowerCase().includes(t) ||
      (u.email || "").toLowerCase().includes(t)
    );
  }, [qtext, users]);

  return (
    <div className="min-h-[calc(100vh-80px)] bg-[#FFE7CC]">
      <div className="max-w-3xl mx-auto p-6">
        <h2 className="text-2xl font-bold text-[#8B6F47] mb-4">Search</h2>
        <input
          value={qtext}
          onChange={(e) => setQtext(e.target.value)}
          placeholder="Search users by name or email"
          className="w-full p-3 rounded-2xl border-2 border-[#E2B887]/40 focus:border-[#E2B887] outline-none bg-white/90"
        />
        <div className="mt-4 space-y-2">
          {filtered.map((u) => (
            <button
              key={u.uid}
              onClick={() => nav(`/u/${u.uid}`)}
              className="w-full flex items-center gap-3 p-3 bg-white/90 rounded-xl hover:bg-white border border-[#E2B887]/30"
            >
              <img
                src={u.photoURL || "https://i.pravatar.cc/40?img=9"}
                className="w-10 h-10 rounded-full object-cover"
              />
              <div className="text-left">
                <div className="text-[#8B6F47] font-semibold">{u.displayName || "Unknown"}</div>
                <div className="text-xs text-[#8B6F47]/70">{u.email}</div>
              </div>
            </button>
          ))}
          {filtered.length === 0 && (
            <div className="text-[#8B6F47]/70">No users found.</div>
          )}
        </div>
      </div>
    </div>
  );
}

.......


// src/pages/UserProfilePage.js
import React, { useEffect, useMemo, useState } from "react";
import { useParams, useNavigate } from "react-router-dom";
import { db } from "../firebase";
import { collection, doc, getDoc, getDocs, orderBy, query, where } from "firebase/firestore";
import { useAuth } from "../context/AuthContext";
import FollowButton from "../components/FollowButton";
import { getFollowCounts } from "../services/socialApi";

export default function UserProfilePage() {
  const { uid } = useParams(); // target user id from /u/:uid
  const { user: me } = useAuth();
  const nav = useNavigate();

  const [profile, setProfile] = useState(null);
  const [posts, setPosts] = useState([]);
  const [counts, setCounts] = useState({ followers: 0, following: 0 });

  useEffect(() => {
    if (!uid) return;
    (async () => {
      const p = await getDoc(doc(db, "users", uid));
      setProfile(p.exists() ? p.data() : { displayName: "User" });

      // posts by this user
      try {
        const q1 = query(collection(db, "posts"), where("uid", "==", uid), orderBy("createdAt", "desc"));
        const ds = await getDocs(q1);
        setPosts(ds.docs.map((d) => ({ id: d.id, ...d.data() })));
      } catch {
        const q2 = query(collection(db, "posts"), where("uid", "==", uid));
        const ds = await getDocs(q2);
        setPosts(ds.docs.map((d) => ({ id: d.id, ...d.data() })));
      }

      // counts
      const { followersCount, followingCount } = await getFollowCounts(uid);
      setCounts({ followers: followersCount, following: followingCount });
    })();
  }, [uid]);

  const name = useMemo(() => profile?.displayName || "User", [profile]);

  return (
    <div className="min-h-[calc(100vh-80px)] bg-[#FFE7CC]">
      <div className="max-w-5xl mx-auto px-4 py-6">
        <div className="bg-white/90 rounded-2xl shadow p-6 flex items-center gap-5">
          <img
            src={profile?.photoURL || "https://i.pravatar.cc/120?img=6"}
            className="w-20 h-20 rounded-full object-cover border"
          />
          <div className="flex-1">
            <div className="flex items-center gap-3">
              <h1 className="text-2xl font-bold text-[#8B6F47]">{name}</h1>
              {me && (
                <FollowButton
                  me={{ uid: me.uid, displayName: me.displayName, photoURL: me.photoURL }}
                  target={{ uid, displayName: profile?.displayName, photoURL: profile?.photoURL }}
                />
              )}
              <button
                onClick={() => nav("/chat")}
                className="px-3 py-1.5 rounded-full bg-[#FFE7CC] border border-[#E2B887]/60 text-[#8B6F47] text-sm"
              >
                Message
              </button>
            </div>
            <div className="mt-1 flex gap-6 text-[#8B6F47]">
              <span><b>{posts.length}</b> posts</span>
              <span><b>{counts.followers}</b> followers</span>
              <span><b>{counts.following}</b> following</span>
            </div>
            {profile?.bio && <p className="mt-2 text-[#8B6F47]/80">{profile.bio}</p>}
          </div>
        </div>

        <div className="mt-6 grid grid-cols-2 md:grid-cols-3 gap-4">
          {posts.length === 0 ? (
            <div className="col-span-full text-center text-[#8B6F47]/70">No posts yet.</div>
          ) : (
            posts.map((p) => (
              <div key={p.id} className="bg-white/90 rounded-xl shadow overflow-hidden">
                {Array.isArray(p.images) && p.images[0] ? (
                  <img src={p.images[0]} alt="" className="w-full aspect-square object-cover" />
                ) : (
                  <div className="w-full aspect-square bg-[#F5F5F5]" />
                )}
                {p.text && <div className="px-3 py-2 text-sm text-[#8B6F47] line-clamp-2">{p.text}</div>}
              </div>
            ))
          )}
        </div>
      </div>
    </div>
  );
}

.......



// imports at top
import { Camera, Search, Home, Bell, Plus, MessageCircle, Settings, User } from "lucide-react";
import { NavLink } from "react-router-dom";

// ... keep your current Layout styles

// Bottom Navigation (replace the previous one)
<nav className="bg-white border-t border-[#E2B887]/30 px-6 py-4">
  <div className="max-w-7xl mx-auto flex items-center justify-around">
    <NavButton icon={Home} to="/home" />
    <NavButton icon={User} to="/profile" />
    <NavButton icon={Plus} to="/add" isCenter />
    <NavButton icon={Search} to="/search" />
    <NavButton icon={Bell} to="/notifications" />
    <NavButton icon={Settings} to="/settings" />
  </div>
</nav>



.........

// src/components/Layout.js
import React from "react";
import { Camera, Search, Home, Bell, Plus, MessageCircle, Settings, User } from "lucide-react";
import { NavLink } from "react-router-dom";

function NavButton({ icon: Icon, to, isCenter }) {
  return (
    <NavLink
      to={to}
      className={({ isActive }) =>
        `relative p-3 rounded-full transition-all flex items-center justify-center ${
          isCenter
            ? "bg-gradient-to-r from-[#E2B887] to-[#B5EAD7] text-white scale-110 shadow-lg"
            : isActive
            ? "bg-[#E2B887]/20 text-[#8B6F47]"
            : "text-[#8B6F47]/60 hover:bg-[#E2B887]/10"
        }`
      }
    >
      <Icon className="w-6 h-6" />
    </NavLink>
  );
}

function Layout({ children }) {
  return (
    <div className="min-h-screen bg-[#FFE7CC] flex flex-col">
      {/* Top Header */}
      <header className="bg-[#FFE7CC] border-b border-[#E2B887]/30 px-6 py-4">
        <div className="max-w-7xl mx-auto flex items-center justify-between">
          <div className="flex items-center space-x-3">
            <div className="w-10 h-10 bg-gradient-to-br from-[#E2B887] to-[#B5EAD7] rounded-full flex items-center justify-center">
              <Camera className="w-6 h-6 text-white" />
            </div>
            <span className="text-2xl font-bold text-[#8B6F47]">PawSnap</span>
          </div>

          <div className="flex items-center space-x-4">
            <div className="relative">
              <Search className="w-5 h-5 text-[#8B6F47] absolute left-3 top-1/2 -translate-y-1/2" />
              <input
                type="text"
                placeholder="Search..."
                className="pl-10 pr-4 py-2 bg-white/60 border-2 border-[#E2B887]/30 rounded-full text-sm focus:outline-none focus:border-[#E2B887] transition"
                // (Optional) you can wire this to navigate("/search") on enter later
                readOnly
              />
            </div>
          </div>
        </div>
      </header>

      {/* Main Content */}
      <div className="flex-1 flex">
        <div className="flex-1 overflow-y-auto">
          <div className="max-w-4xl mx-auto p-6">{children}</div>
        </div>
      </div>

      {/* Bottom Navigation: Home / Profile / Message  (+)  Search / Notifications / Settings */}
      <nav className="bg-white border-t border-[#E2B887]/30 px-6 py-4">
        <div className="max-w-7xl mx-auto flex items-center justify-around">
          <NavButton icon={Home} to="/home" />
          <NavButton icon={User} to="/profile" />
          <NavButton icon={MessageCircle} to="/chat" />

          <NavButton icon={Plus} to="/add" isCenter />

          <NavButton icon={Search} to="/search" />
          <NavButton icon={Bell} to="/notifications" />
          <NavButton icon={Settings} to="/settings" />
        </div>
      </nav>
    </div>
  );
}

export default Layout;


.........


// src/App.js
import "./firebase";
import React from "react";
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import { AuthProvider } from "./context/AuthContext";
import { DataProvider } from "./context/DataContext";
import Layout from "./components/Layout";
import ProtectedRoute from "./components/ProtectedRoute";

import AuthScreen from "./pages/AuthScreen";
import HomePage from "./pages/HomePage";
import AddPostPage from "./pages/AddPostPage";
import ChatPage from "./pages/ChatPage";
import SettingsPage from "./pages/SettingsPage";
import ProfilePage from "./pages/ProfilePage";

// NEW pages you added for social:
import SearchPage from "./pages/SearchPage";
import NotificationsPage from "./pages/NotificationsPage";
import UserProfilePage from "./pages/UserProfilePage";

function App() {
  return (
    <Router>
      <AuthProvider>
        <Routes>
          {/* Public route (login/register) */}
          <Route path="/" element={<AuthScreen />} />

          {/* Private app */}
          <Route
            path="*"
            element={
              <ProtectedRoute>
                <DataProvider>
                  <Layout>
                    <Routes>
                      <Route path="/home" element={<HomePage />} />
                      <Route path="/add" element={<AddPostPage />} />
                      <Route path="/chat" element={<ChatPage />} />
                      <Route path="/profile" element={<ProfilePage />} />

                      {/* NEW */}
                      <Route path="/u/:uid" element={<UserProfilePage />} />
                      <Route path="/search" element={<SearchPage />} />
                      <Route path="/notifications" element={<NotificationsPage />} />

                      <Route path="/settings" element={<SettingsPage />} />
                    </Routes>
                  </Layout>
                </DataProvider>
              </ProtectedRoute>
            }
          />
        </Routes>
      </AuthProvider>
    </Router>
  );
}

export default App;

...............



// src/pages/HopeHubPage.js
import React, { useState } from "react";
import { ChevronDown, ChevronUp, Info } from "lucide-react";
import { useNavigate } from "react-router-dom";

export default function HopeHubPage() {
  const [open, setOpen] = useState(false); // Read Me drawer
  const navigate = useNavigate();

  return (
    <div className="min-h-[calc(100vh-80px)] bg-[#FFE7CC]">
      {/* Local page header (keeps your global Layout intact) */}
      <div className="sticky top-0 z-10 bg-[#FFE7CC]/95 backdrop-blur border-b border-[#E2B887]/30">
        <div className="max-w-5xl mx-auto px-4 py-3 flex items-center justify-between">
          {/* Left: Contacts (same size as Read Me) */}
          <button
            onClick={() => navigate("/chat")}
            className="px-3 py-1.5 rounded-full text-[#8B6F47] border border-[#E2B887]/50 bg-white/70 hover:bg-white transition text-sm"
          >
            Contacts
          </button>

          {/* Center: HOPE HUB (big + centered) */}
          <div className="text-2xl font-extrabold text-[#8B6F47]">
            HOPE HUB
          </div>

          {/* Right: Read Me toggle (same size as Contacts) */}
          <button
            onClick={() => setOpen((v) => !v)}
            className="px-3 py-1.5 rounded-full text-[#8B6F47] border border-[#E2B887]/50 bg-white/70 hover:bg-white transition flex items-center gap-2 text-sm"
            aria-expanded={open}
          >
            Read Me {open ? <ChevronUp className="w-4 h-4" /> : <ChevronDown className="w-4 h-4" />}
          </button>
        </div>

        {/* Read Me drawer */}
        <div
          className={`overflow-hidden transition-[max-height,opacity] duration-300 ${
            open ? "max-h-96 opacity-100" : "max-h-0 opacity-0"
          }`}
        >
          <div className="max-w-5xl mx-auto px-4 pb-3">
            <div className="bg-white/80 rounded-xl shadow border border-[#E2B887]/40 p-4">
              <div className="flex items-start gap-3">
                <div className="shrink-0">
                  <Info className="w-5 h-5 text-[#8B6F47]" />
                </div>
                <div className="text-[#8B6F47] leading-relaxed">
                  <p className="font-semibold mb-1">🐾 Welcome to Hope Corner</p>
                  <p>
                    A place where care meets action. If you’ve <b>lost or found a pet</b>, or see an <b>animal
                    needing help</b>, share it here. Add a few details, a picture, and where you last saw them —
                    every post brings hope closer. Together, we make sure no paw is left behind. 💛
                  </p>
                  <p className="mt-3 font-semibold">— @PawSnap Team</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Page body (we’ll add report form + feed later) */}
      <div className="max-w-5xl mx-auto px-4 py-6">
        {/* Placeholder actions for next step */}
        <div className="flex items-center gap-3 mb-4">
          <button
            onClick={() => {/* later: navigate to /report/create */}}
            className="px-4 py-2 rounded-full bg-[#E2B887] text-white hover:brightness-95"
          >
            + Create Report
          </button>
          <div className="text-[#8B6F47]/70 text-sm">
            (Coming soon: Lost / Found / Needs Help filters & feed)
          </div>
        </div>

        <div className="bg-white/80 rounded-2xl shadow p-6 border border-[#E2B887]/30 text-[#8B6F47]/70">
          This is your Hope Hub. Next we’ll wire the report form & feed here.
        </div>
      </div>
    </div>
  );
}
